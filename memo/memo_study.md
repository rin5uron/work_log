# 📝 学習メモ

## 📋 目次

### HTML関連
- [マークダウン記法](#マークダウン記法)
- [index.htmlについて](#indexhtmlについて)
- [Emmetショートカット](#emmetショートカット)
- [trタグとdivタグの適切な使い分け](#trタグとdivタグの適切な使い分け)
- [マークダウンでの画像表示と調整方法](#マークダウンでの画像表示と調整方法)
- [ビューポートメタタグ](#ビューポートメタタグ)
- [HTMLとCSS](#htmlとcss)
- [HTML構造](#html構造)

### CSS関連
- [箇条書きのインデント調整](#箇条書きのインデント調整)
- [CSSプロパティの継承に関する注意点](#cssプロパティの継承に関する注意点)
- [transformプロパティのアニメーション](#transformプロパティのアニメーション)
- [CSS関連（詳細）](#css関連)
- [CSS擬似要素（::before, ::after）](#css擬似要素before-after)
- [ホバー効果とカーソルプロパティ](#ホバー効果とカーソルプロパティ)
- [marginプロパティの詳細](#marginプロパティの詳細)
- [max-widthプロパティの詳細](#max-widthプロパティの詳細)
- [overflow: hidden](#overflow-hidden)
- [リセットスタイル](#リセットスタイル)
- [フォントフォールバック](#フォントフォールバック)
- [Flexboxレイアウト](#flexboxレイアウト)
- [displayプロパティの詳細](#displayプロパティの詳細)
- [align-itemsプロパティの詳細](#align-itemsプロパティの詳細)
- [よく使われるFlexboxの組み合わせパターン](#よく使われるflexboxの組み合わせパターン)
- [CSSの優先順位](#cssの優先順位)
- [パディング指定](#パディング指定)
- [width設定のポイント](#width設定のポイント)
- [CSSセレクタの種類](#cssセレクタの種類)
- [要素セレクタとクラスセレクタの違い](#要素セレクタとクラスセレクタの違い)
- [内部CSSの配置](#内部cssの配置)
- [インラインスタイル](#インラインスタイル)
- [CSSサンプル](#cssサンプル)

### JavaScript関連
- [アコーディオンメニューの開閉制御](#アコーディオンメニューの開閉制御)
- [イベント駆動型プログラミング](#イベント駆動型プログラミング)
- [JavaScript基本構文とよくあるエラー](#javascript基本構文とよくあるエラー)
- [includes()メソッド](#includesメソッド)
- [配列メソッド](#配列メソッド)
- [JavaScript構造](#javascript構造)
- [使用コード（HTML＋JavaScript）](#使用コードhtmljavascript)

### Web開発全般
- [Web関連の基礎知識](#web関連の基礎知識)
- [コーディングとノーコード開発の比較](#コーディングとノーコード開発の比較)

### Git・GitHub関連
- [基本用語](#基本用語)
- [ステージングについて](#ステージングについて)
- [node_modulesフォルダとGitHub](#node_modulesフォルダとgithub)
- [ワークスペースとGit管理について](#ワークスペースとgit管理について)
- [.gitignoreとは](#gitignoreとは)
- [正しい配置場所](#正しい配置場所)
- [ルートディレクトリに置く理由](#ルートディレクトリに置く理由)
- [よくある問題と対処法](#よくある問題と対処法)
- [重要なポイント](#重要なポイント)

### ツール・開発環境
- [サジェスト機能の使い方](#サジェスト機能の使い方)
- [手動で候補を表示する方法](#手動で候補を表示する方法)
- [HTMLのショートカット入力](#htmlのショートカット入力)

### ネットワーク・インフラ関連
- [用語の役割まとめ](#用語の役割まとめ)
- [IPアドレスとは？](#ipアドレスとは)
- [MACアドレスとは？](#macアドレスとは)
- [ポート番号とは？](#ポート番号とは)
- [プライベートWi-Fiアドレスとは？](#プライベートwi-fiアドレスとは)
- [補足：Wi-Fi接続履歴と追跡について](#補足wi-fi接続履歴と追跡について)
- [イメージで覚える！](#イメージで覚える)

### Web技術・RSS関連
- [RSSとは？](#rssとは)
- [RSSの設定方法（WebサイトをRSS対応にする方法）](#rssの設定方法websiteをrss対応にする方法)
- [RSSの取得方法（使う側の視点）](#rssの取得方法使う側の視点)
- [補足：RSSに非対応のサイトは？](#補足rssに非対応のサイトは)
- [まとめ](#まとめ)

### その他・技術概念
- [仕組み](#仕組み)
- [図でイメージ](#図でイメージ)
- [ポイント](#ポイント)
- [注意点](#注意点)
- [メリット](#メリット)
- [これは何？](#これは何)
- [例](#例)
- [どんな効果？](#どんな効果)
- [大事なポイント](#大事なポイント)
- [さらに深掘り](#さらに深掘り)
<br>
<br>
フォーマット
---

# セクション名

**学習日：** 2025/00/00  
**カテゴリ：** HTML / CSS / JavaScript / Web技術 / Git・GitHub / ツール・開発環境 / その他

## 📖 概要
<!-- このセクションで学んだことの簡単な概要 -->

## 🔍 詳細内容

### 用語・概念名
**役割・定義：**
- 簡潔な説明

**使用場面：**
- どういう時に使うか

**コード例：**
```html/css/javascript
<!-- 実際のコード例 -->
```

**ポイント：**
- 重要なポイント1
- 重要なポイント2

## 💡 学んだこと・気づき
- 実際に使ってみて分かったこと
- つまずいたポイントと解決方法
- 今後活用できそうなこと

## 🔗 関連リンク・参考資料
- 参考にした記事やドキュメント
- 関連する他のセクション

---

<br>
<br>
# マークダウン記法
### マークダウンの基本的な記述方法
- **マークダウンの改行**：マークダウンでは単に改行を入れても表示上の改行にならない。改行するには以下の方法がある：
  1. 行末に半角スペース2つを入れる
  2. `<br>`タグを使用する
  3. 空行を入れて段落を分ける（完全に別の段落になる）

# index.htmlについて
### index.htmlの基本的な役割
- Webサーバーのデフォルトファイル名として認識される
- URLでディレクトリ名のみを指定した場合（例：`example.com/folder/`）、自動的に`index.html`が表示される
- フォルダのトップページ・メインページとして使われる慣習的な命名規則

# Emmetショートカット
### HTMLのショートカット入力
- `!` + `Tab` - HTML5の基本構造を自動生成
- `html:5` + `Tab` - 同じく基本構造生成

# trタグとdivタグの適切な使い分け
### trタグとdivタグの適切な使い分け方 📝 2025/04/21

HTMLでテーブル（表）を作成する際と単純なレイアウト目的での要素の使い分け方について整理しました。

#### trタグの用途と特徴
- `<tr>` (table row)はテーブル（`<table>`）内で行を表現するための専用タグ
- 必ず`<table>`の中で使用する必要がある
- `<tr>`の中には`<td>`（テーブルデータ）や`<th>`（テーブルヘッダー）要素を配置する
- 表形式のデータを表現する時に適している
- テーブルのセマンティクス（意味構造）を正しく表現できる

```html
<table>
  <tr>
    <th>ヘッダー1</th>
    <th>ヘッダー2</th>
  </tr>
  <tr>
    <td>データ1</td>
    <td>データ2</td>
  </tr>
</table>
```

#### divタグの用途と特徴
- `<div>`はブロックレベル要素を作る汎用的なコンテナ
- レイアウトの区切りや、スタイルを適用するためのグループ化に使用
- 意味的な構造を持たないため、純粋にレイアウト目的に適している
- CSSと組み合わせて柔軟なデザインが可能

```html
<div class="container">
  <div class="row">
    <div class="cell">データ1</div>
    <div class="cell">データ2</div>
  </div>
</div>
```

#### 使い分けのポイント
1. **データの性質を考慮**: 表形式のデータを表示する場合は`<table>`を使用
2. **アクセシビリティ**: スクリーンリーダーなどの支援技術を使用するユーザーのために、データの構造を正しく伝えるためにも適切な要素を選択する
3. **レスポンシブデザイン**: 単純なレイアウト目的なら`<div>`の方が柔軟に対応できる

#### 注意点
- 昔はテーブルレイアウト（`<table>`を使ったページのレイアウト）が一般的だったが、現在はCSSを使った方法が推奨されている
- SEOの観点からも、適切な要素を使うことが重要

# マークダウンでの画像表示と調整方法
### マークダウンでの画像表示と調整方法 📝 2025/04/21

マークダウンでは通常、以下の形式で画像を挿入します：

```markdown
![代替テキスト](画像のURL "オプションのタイトル")
```

しかし、サイズ調整やセンタリングなどの細かい制御が必要な場合は、HTMLタグを使用することができます。

#### 画像サイズの調整
```html
<img src="画像のパス" width="300" height="200" alt="代替テキスト">
```

#### 画像の中央揃え
```html
<div align="center">
  <img src="画像のパス" alt="代替テキスト">
</div>
```

#### 画像にリンクを設定
```markdown
[![代替テキスト](画像のパス)](リンク先URL)
```

#### スタイルを適用した画像
```html
<img src="画像のパス" alt="代替テキスト" style="border: 1px solid #ddd; border-radius: 8px; padding: 5px;">
```

#### 画像のフロート（テキスト回り込み）
```html
<img src="画像のパス" alt="代替テキスト" style="float: right; margin: 0 0 10px 10px;">
テキストがここに入ります。画像は右側に配置され、テキストが画像の周りに回り込みます。
<div style="clear: both;"></div><!-- フロートのクリア -->
```

#### 注意点
- GitHubやNotion等のプラットフォームでは、セキュリティ上の理由からHTMLタグの一部が制限されていることがある
- マークダウンの実装によって、対応しているHTMLタグやCSSプロパティが異なる場合がある
- 複雑なレイアウトが必要な場合は、純粋なHTMLドキュメントを作成した方が柔軟性が高い

## ビューポートメタタグ
### ビューポートメタタグの役割と設定方法
```html
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

この設定は2つの重要な部分から成ります：

1. **width=device-width**
   - ページの幅をデバイスの画面幅に合わせる
   - 様々な画面サイズのデバイスで適切に表示される

2. **initial-scale=1.0**
   - 初期表示時のズームレベルを100%（等倍）に設定
   - ページが拡大・縮小されずにそのままの比率で表示される

**重要性**：
- モバイルデバイスでの適切な表示を保証
- レスポンシブデザインの基盤となる設定
- ユーザーが拡大操作なしでコンテンツを閲覧できる
- メディアクエリと組み合わせて異なる画面サイズに対応

## 箇条書きのインデント調整
### 箇条書きの2行目以降を揃える方法（2025/04/21）
- 問題点
  - 箇条書きの2行目以降がマーク（・）よりも左に揃ってしまう
  - 長文の場合、テキストが左端から始まるため読みにくくなる
  
- 解決方法：text-indentプロパティの活用
  ```css
  li {
    padding-left: 1.5em;  /* マークより右側にテキスト全体を配置 */
    text-indent: -1.5em;  /* 最初の行だけ左にずらす（マークを表示） */
  }
  ```
  
- 仕組みの解説
  1. `padding-left: 1.5em;` でリスト全体を右側にずらす
  2. `text-indent: -1.5em;` で最初の行だけ左に戻す（負の値）
  3. 結果として、マークは元の位置に、2行目以降はマークの右に揃う
  
- 応用例（カスタム箇条書き）
  ```css
  .custom-list {
    list-style: none;  /* 標準の箇条書きマークを非表示 */
  }
  
  .custom-list li {
    padding-left: 1.4em;
    text-indent: -1.4em;
  }
  
  .custom-list li:before {
    content: "✓";  /* カスタムマーク */
    margin-right: 0.4em;
  }
  ```
  
- 注意点
  - padding-leftとtext-indentの値は一致させるのが基本
  - emやremなどの相対単位を使うと、フォントサイズが変わっても調整される
  - ネストされたリストでは、階層ごとに異なる値を設定すると良い

## CSSプロパティの継承に関する注意点 📝
### 継承されるプロパティと継承されないプロパティ（2025/04/21）
- 継承されるプロパティ（親要素から子要素に自動的に引き継がれる）
  - `color` - テキストの色
  - `font-family` - フォントの種類
  - `font-size` - フォントサイズ
  - `font-weight` - フォントの太さ
  - `line-height` - 行の高さ
  - `text-align` - テキストの配置
  - `visibility` - 表示/非表示（スペースは維持）
  
- 継承されないプロパティ（子要素に自動的に引き継がれない）
  - `margin`, `padding` - 余白関連
  - `border` - 境界線
  - `background` - 背景
  - `width`, `height` - サイズ
  - `position` - 配置方法
  - `display` - 表示形式
  - `z-index` - 重ね順
  
- 継承を制御するための値
  - `inherit` - 親要素の値を強制的に継承させる
  - `initial` - ブラウザの初期値に戻す
  - `unset` - 継承するプロパティは継承し、しないプロパティは初期値に戻す
  
- 実用例
  ```css
  /* すべてのボタンに親要素のフォントカラーを継承させる */
  button {
    color: inherit;
  }
  
  /* ボックスの背景色を強制的にリセットする */
  .reset-box {
    background-color: initial;
  }
  ```
  
- 注意点
  - 継承は直接の親だけでなく、先祖要素からも引き継がれる
  - CSSの詳細度（セレクタの強さ）によって継承よりも強いルールが適用される場合がある
  - `!important`を使うと継承よりも優先される

## transformプロパティのアニメーション 📝
### transform: rotate()を使った要素の回転（2025/04/21）
- 基本構文
  ```css
  .element {
    transform: rotate(90deg); /* 時計回りに90度回転 */
    transition: transform 0.5s; /* 0.5秒かけて回転するアニメーション */
  }
  ```
- 主な回転値
  - `rotate(45deg)` - 時計回りに45度回転
  - `rotate(-90deg)` - 反時計回りに90度回転
  - `rotate(0.5turn)` - 180度回転（turnは1回転を表す単位）
- 回転の中心点の変更
  ```css
  .element {
    transform-origin: top left; /* 左上を中心に回転 */
    transform: rotate(45deg);
  }
  ```
- 実用例：ボタン内の矢印アイコンを回転
  ```css
  .accordion-header.active .arrow {
    transform: rotate(180deg); /* アコーディオンが開いたときに矢印を回転 */
  }
  ```
- 注意点
  - 回転は要素の表示位置を変えるだけで、ドキュメントのレイアウトには影響しない
  - 3D回転をするには `rotateX()`, `rotateY()`, `rotateZ()` を使用する

## 【CSS関連】

### CSS基本プロパティと使い方

#### ホバー効果とカーソルプロパティ

**ホバー（:hover）疑似クラス**

ホバーとは、マウスカーソルを要素の上に置いた状態のことです。CSSでは`:hover`疑似クラスを使用して、この状態の時のスタイルを指定できます。

**基本的な使い方:**
```css
.button:hover {
  background-color: blue;  /* ホバー時は背景色が青に変わる */
}
```

#### CSS擬似要素（::before, ::after）

擬似要素とは「HTMLには書いていないけど、CSSだけで追加できる架空の要素」のことです。HTMLを変更せずにCSSだけで内容を追加できる強力な機能です。

**主な擬似要素:**
- **::before** - 要素の中身の前に何かを追加
- **::after** - 要素の中身の後に何かを追加

**基本的な使い方:**
```css
.example::before {
  content: "★"; /* 必須プロパティ。挿入する内容を指定 */
  color: red;    /* 通常の要素と同様にスタイリングできる */
}

.example::after {
  content: "☆";
  margin-left: 5px;
}
```

**実用例（アコーディオンメニューの+/-アイコン）:**
```css
.accordion-header::after {
  content: '+';   /* + 記号を挿入 */
  float: right;   /* 右側に配置 */
}

/* アクティブ状態では - 記号に変更 */
.accordion-header.active::after {
  content: '-';
}
```

**擬似要素を使うメリット:**
1. HTMLをシンプルに保てる（装飾目的のタグが減る）
2. JavaScriptを使わずにデザイン的な効果が得られる
3. 内容とデザインの分離がしやすくなる

#### marginプロパティの詳細

`margin`プロパティは要素の外側の余白（マージン）を設定するためのCSSプロパティです。

**値の指定方法:**

1. **一括指定**
   - `margin: 10px;` - 上下左右すべての余白を10pxに設定

2. **方向別の指定**
   - `margin-top`, `margin-right`, `margin-bottom`, `margin-left` - 各方向の余白を個別に指定

3. **省略記法（ショートハンド）**
   - `margin: 上 右 下 左;` - 時計回りで4つの値を指定
   - `margin: 上下 左右;` - 2つの値を指定（上下共通、左右共通）
   - `margin: 上 左右 下;` - 3つの値を指定（左右は共通）

**特別な値:**

1. **`auto`** - ブラウザによる自動計算
   - `margin: 0 auto;` - 上下マージンは0、左右マージンは自動計算により中央揃えを実現
   - 要素に幅（width）が設定されている場合に有効
   - ブロックレベル要素の水平中央配置に広く使用される
   - `<div>`, `<p>`, `<section>`などの要素を中央揃えにする際に便利

2. **負の値** - 要素を通常の配置位置から反対方向に移動させる
   - `margin-top: -20px;` - 要素を上方向に20px移動

**使用例と実践的なパターン:**

```css
/* コンテンツを中央揃えにするコンテナ */
.container {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto; /* 上下余白なし、左右自動で中央揃え */
}

/* カードデザインの余白設定 */
.card {
  margin: 20px; /* 全方向に20pxの余白 */
}

/* 段落間の間隔設定 */
p {
  margin: 0 0 1em 0; /* 上:0、右:0、下:1em、左:0 */
}
```

**注意点:**

- 複数要素間のマージンは「マージンの相殺（Margin Collapse）」が発生することがある（上下方向のみ）
- 特に垂直方向のレイアウトでは、隣接する要素同士のマージンは大きい方の値が採用される
- インライン要素には左右のマージンのみ適用され、上下のマージンは無視される

#### max-widthプロパティの詳細

`max-width`プロパティは要素の最大幅を制限するためのCSSプロパティです。要素は通常、親要素や内容に基づいて幅が決まりますが、`max-width`を設定すると指定した値以上に広がらなくなります。

**主な特徴と使い方:**

1. **レスポンシブデザインでの活用**
   - 大きな画面では幅を制限し、小さな画面では`width: 100%`と組み合わせて画面幅に合わせる
   - `max-width: 1200px;` - 画面が1200pxより広くても、要素は1200px以上に広がらない
   - `width: 100%;` と組み合わせると、小さな画面では画面いっぱいに、大きな画面では制限された幅で表示

2. **コンテンツの読みやすさの向上**
   - テキストコンテンツは行の長さが適切な範囲内（約50〜75文字）だと読みやすい
   - `max-width: 800px;` - 本文コンテナなどに設定し、行の長さを適切に保つ

3. **メディア要素の制御**
   - 画像やビデオが親要素からはみ出すのを防ぐ
   - `max-width: 100%;` - 画像やビデオを親要素より大きくならないように制限（レスポンシブイメージの基本テクニック）

**実用的な使用例:**

```css
/* レスポンシブなメインコンテナ */
.main-container {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
}

/* 読みやすい本文エリア */
.article-content {
  width: 100%;
  max-width: 800px;
  margin: 0 auto;
}

/* レスポンシブな画像 */
img {
  max-width: 100%;
  height: auto;
}
```

**max-widthとwidthの違い:**

- `width` - 要素の固定幅を設定
- `max-width` - 要素が広がる最大値を制限するが、画面が小さくなると自動的に縮小

**他の関連プロパティ:**

- `min-width` - 要素の最小幅を設定
- `width` - 要素の幅を設定
- `max-height` - 要素の最大高さを設定
- `min-height` - 要素の最小高さを設定

**レスポンシブデザインでの典型的なパターン:**

```css
.container {
  width: 100%;      /* 小さい画面では画面幅いっぱいに広がる */
  max-width: 500px; /* 大きい画面では500pxを超えない */
  margin: 0 auto;   /* 中央揃え */
}
```

**このパターンの効果:**
- モバイル画面ではコンテナが画面幅いっぱいに表示される
- 画面が広くなるにつれてコンテナも広がるが、500pxを超えることはない
- 画面幅が500pxを超えると、コンテナは中央に配置される

**ポイント:**
- レスポンシブデザインの基本テクニック
- 異なる画面サイズでの一貫したユーザー体験を提供
- モバイルファーストの設計アプローチと相性が良い

#### overflow: hidden
ボックスからはみ出た内容を非表示にするプロパティ。
- アコーディオンメニューでは閉じた時に内容を完全に隠す
- メニューの開閉アニメーションをきれいに見せるために必要
- 値：visible（表示）、hidden（非表示）、scroll（常にスクロール）、auto（必要時スクロール）

#### リセットスタイル
ブラウザの標準スタイル設定をリセットするためのCSSコード。
- `margin: 0;` - すべての余白をゼロに
- `padding: 0;` - すべての内部余白をゼロに
- `box-sizing: border-box;` - ボーダーとパディングを幅と高さに含める

#### フォントフォールバック
`font-family: 'Helvetica Neue', Arial, sans-serif;`
- 左から順に適用を試みる（最初がなければ次を使用）
- 最後は必ずジェネリックファミリー（sans-serif等）を指定

#### Flexboxレイアウト
要素を柔軟に配置・整列させるための仕組み。
- `display: flex;` - フレックスボックスレイアウト
- `justify-content: center;` - 水平方向の配置
- `align-items: center;` - 垂直方向の配置
- `flex-direction: row/column;` - 並ぶ方向

### displayプロパティの詳細

`display`プロパティはHTML要素の表示方法を指定する最も基本的なCSSプロパティです。

#### 主な値と効果:

1. **`display: block`**
   - 要素が1行全体を占有する
   - 幅と高さを指定可能
   - `<div>`, `<p>`, `<h1>`などはデフォルトでblock
   - 前後に自動的に改行が入る

2. **`display: inline`**
   - テキストの流れに沿って表示される
   - 幅と高さを直接指定できない
   - `<span>`, `<a>`, `<strong>`などはデフォルトでinline
   - 改行なしで横に並ぶ

3. **`display: inline-block`**
   - inlineとblockの特性を組み合わせたもの
   - 横に並ぶが、幅と高さを指定できる
   - フォームの要素などによく使われる

4. **`display: none`**
   - 要素を完全に非表示にする
   - レイアウトにも影響しない（スペースも占有しない）
   - JavaScriptで動的に表示/非表示の切り替えに使用

5. **`display: flex`**
   - 要素をフレックスコンテナに変換する
   - 子要素（フレックスアイテム）を柔軟にレイアウト可能
   - 一次元のレイアウト（横または縦の一方向）に最適
   - モバイルフレンドリーなレスポンシブデザインに適している

6. **`display: grid`**
   - 要素をグリッドコンテナに変換する
   - 行と列の二次元レイアウトを実現
   - 複雑なレイアウトを簡潔に記述可能
   - グリッドラインに基づいた正確な配置が可能

7. **`display: table`系**
   - HTMLのテーブル要素と同様の表示形式
   - `table`, `table-row`, `table-cell`などの値がある
   - 表形式のレイアウトを実現できるが、現在はflexやgridの利用が推奨

### align-itemsプロパティの詳細

`align-items`プロパティはFlexboxとGridレイアウトにおいて、コンテナ内の子要素をクロスアクシス（交差軸）上でどのように配置するかを指定します。Flexboxのデフォルト設定でクロスアクシスは縦方向（垂直方向）です。

#### 主な値と効果:

1. **`align-items: stretch`** (デフォルト値)
   - 子要素をコンテナの高さいっぱいに引き伸ばす
   - 子要素の高さが明示的に指定されていない場合のみ有効
   - サイドバーとメインコンテンツを同じ高さにするのに便利

2. **`align-items: flex-start`**
   - 子要素をクロスアクシスの開始位置（上端）に配置
   - 異なる高さの要素が上端で揃う
   - ヘッダーなどのトップに揃えたい場合に使用

3. **`align-items: flex-end`**
   - 子要素をクロスアクシスの終了位置（下端）に配置
   - 異なる高さの要素が下端で揃う
   - フッターなどの下部に揃えたい場合に使用

4. **`align-items: center`**
   - 子要素をクロスアクシスの中央に配置
   - 垂直方向の中央揃えを実現
   - ナビゲーションバーやモーダルウィンドウの中央配置に最適

5. **`align-items: baseline`**
   - 子要素のテキストのベースライン（文字の下線）で揃える
   - 異なるフォントサイズのテキストを綺麗に整列させるのに有効
   - タイポグラフィを重視するデザインで役立つ

**使用例:**

```css
/* 縦方向に中央揃えのナビゲーションバー */
.navbar {
  display: flex;
  height: 80px;
  align-items: center;
}

/* カードの内容を上部に揃える */
.card-container {
  display: flex;
  align-items: flex-start;
}

/* 全ての子要素を同じ高さにする */
.sidebar {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
```

**ポイント:**
- `flex-direction: column`を使用すると、メインアクシスと交差アクシスが入れ替わるため、`align-items`の効果も横方向に変わる
- Grid内での`align-items`はグリッドセル内の要素の配置を制御する
- `align-content`プロパティと混同しないこと（`align-content`は複数行にわたるフレックスアイテム全体の配置を制御）

### よく使われるFlexboxの組み合わせパターン

```css
.container {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
```

**詳細説明**:

1. **`display: flex`**
   - 対象の要素をフレックスコンテナに変換する
   - 子要素（フレックスアイテム）は初期設定で横並びになる
   - フレックスアイテムは自動的に伸縮し、親コンテナの領域に合わせて調整される
   - ブロック要素でもインライン要素でも適用可能

2. **`justify-content: space-between`**
   - メインアクシス（横方向）に沿った配置を指定
   - `space-between`は最初の要素を左端、最後の要素を右端に配置し、残りの要素を均等に分散
   - 子要素間の空白が均等になるよう自動調整される
   - 他の値: `flex-start`（左揃え）、`flex-end`（右揃え）、`center`（中央揃え）、`space-around`（周囲の余白均等）など

3. **`align-items: center`**
   - クロスアクシス（縦方向）に沿った配置を指定
   - `center`は子要素を縦方向の中央に配置
   - コンテナの高さより子要素の高さが小さい場合に、その効果が顕著に表れる
   - 他の値: `flex-start`（上揃え）、`flex-end`（下揃え）、`stretch`（親に合わせて伸縮）、`baseline`（ベースラインで揃える）

**このパターンの一般的な使用例**:
- ナビゲーションバー: ロゴを左、メニューを右に配置
- アコーディオンヘッダー: タイトルを左、開閉アイコンを右に配置
- カード内のフッター: 「詳細」ボタンを左、「いいね」ボタンを右に配置
- フォーム要素: ラベルを左、入力フィールドを右に配置

**ポイント**:
- 直感的で簡単に両端揃えと垂直中央揃えが実現できる
- レスポンシブデザインと相性が良い
- 従来のfloatやpositionを使った複雑なレイアウトよりもはるかに簡潔に記述できる
- ブラウザ互換性が高い（IE11以降、他の主要ブラウザは全て対応）

#### CSSの優先順位
1. 詳細度が高いセレクタが優先（インラインスタイル > ID > クラス > 要素）
2. 同じ詳細度なら後に書かれたスタイルが優先
3. !important指定は最優先（使用は避ける）

#### パディング指定
- 個別：`padding-top/right/bottom/left`
- 4値：`padding: 上 右 下 左`（時計回り）
- 3値：`padding: 上 右左 下`
- 2値：`padding: 上下 右左`
- 1値：`padding: 全方向`

### width設定のポイント

#### 基本的な考え方
1. **コンテンツに適した幅を選ぶ**
   - テキスト中心なら600〜700px程度（日本語20〜40文字が読みやすい）
   - 画像やリッチコンテンツなら必要に応じて広く

2. **レスポンシブデザインを考慮**
   - モバイル：画面幅の90〜100%
   - デスクトップ：最大幅（max-width）を設定

3. **基本的な設定方法**
   ```css
   .element {
     width: 90%;          /* 親要素の90% */
     max-width: 700px;    /* 最大幅を制限 */
     margin: 0 auto;      /* 中央揃え */
   }
   ```

#### 実用的なテクニック
- **コンテナ要素**には`max-width`で上限を設定
- **中身の要素**には`width: 100%`で親に合わせる
- `box-sizing: border-box`を使うとpadding/borderを含めた幅指定ができる

#### 注意点
- 幅が広すぎると行長が長くなり読みにくい
- 狭すぎると改行が多くなり不自然
- ユーザーの視線移動と画面サイズを考慮する

### 内部CSSの配置

HTMLファイル内で`<style>`タグを使って直接CSSコードを記述する場合、適切な配置場所は`<head>`タグの中で、特に終了直前が推奨されます。

**正しい配置順序:**
1. 文字コード設定: `<meta charset="UTF-8">`
2. ビューポート設定: `<meta name="viewport">`
3. タイトル情報: `<title>`
4. 外部CSSファイル: `<link rel="stylesheet">`
5. 内部CSS: `<style>` タグ

**コード例:**
```html
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ページタイトル</title>
  <link rel="stylesheet" href="external.css">
  <style>
    /* 内部CSS */
    body {
      font-family: sans-serif;
    }
    .container {
      margin: 0 auto;
    }
  </style>
</head>
```

**ポイント:**
- 基本情報（文字コードなど）を先に読み込んでから、スタイル情報を読み込む
- 外部CSSファイルを先に読み込み、内部CSSで上書きや調整ができるようにする
- 優先順位の関係上、同じセレクタの場合は後に記述されたスタイルが適用される

### インラインスタイル

HTMLの要素に直接`style`属性としてCSSを記述する方法です。

**基本構文:**
```html
<要素名 style="プロパティ1: 値1; プロパティ2: 値2;">コンテンツ</要素名>
```

**実例:**
```html
<body style="max-width: 800px; margin: 0 auto; padding: 20px; font-family: sans-serif;">
```

**特徴:**
- その要素だけに適用されるスタイルを定義できる
- 他のCSSスタイル（内部CSSや外部CSS）よりも優先度が高い
- HTMLとCSSが混在するため、コードの管理が難しくなることがある
- 同じスタイルを複数の要素に適用したい場合は非効率

**使い分け:**
- 1回限りの特別なスタイル適用に適している
- プロトタイプ作成や簡単なデモページに便利
- 大規模サイトでは保守性の観点から避けるべき
- JavaScriptでスタイルを動的に変更する場合にも使用される

**CSS適用方法の比較:**
1. インラインスタイル: 個別要素に直接記述（優先度最高）
2. 内部CSS: ページ内の複数要素に適用（`<head>`内の`<style>`タグ）
3. 外部CSS: 複数ページに適用（別ファイルを`<link>`で読み込み）

### CSSセレクタの種類

#### 要素セレクタとクラスセレクタの違い

CSSでは様々な方法で装飾対象を指定できますが、主に以下の2種類のセレクタが基本となります：

**要素セレクタ**
- HTMLタグを直接指定するセレクタ
- ピリオド（.）は付けません
- 例：`body { }`, `footer { }`, `h1 { }`
- 該当するHTML要素全てにスタイルが適用されます
- `body { background-color: white; }` はページ全体の背景色を白に設定

**クラスセレクタ**
- class属性を持つ要素を指定するセレクタ
- ピリオド（.）を先頭に付ける必要があります
- 例：`.main-container { }`, `.accordion-item { }`
- 特定のクラス名を持つ要素のみにスタイルが適用されます
- `.active { color: red; }` は`class="active"`を持つ要素のテキストを赤色に設定

**実践的な使い方：**
```css
/* 要素セレクタ - 全てのh1要素に適用 */
h1 {
  font-size: 24px;
  color: #333;
}

/* クラスセレクタ - class="highlight"を持つ全ての要素に適用 */
.highlight {
  background-color: yellow;
  padding: 5px;
}

/* 要素とクラスの組み合わせ - class="special"を持つh2要素のみに適用 */
h2.special {
  border-bottom: 2px solid blue;
}
```

**セレクタ選択の基準：**
- 全てのページ要素に共通スタイルを適用する場合 → 要素セレクタ
- 特定の要素群だけに限定したスタイルを適用する場合 → クラスセレクタ
- 細かく制御したい場合は、クラスセレクタの方が一般的に適しています

## 【JavaScript関連】

### アコーディオンメニューの開閉制御
```javascript
// アコーディオンメニュー制御
accordionHeader.addEventListener('click', function() {
    // コンテンツ部分を取得
    const content = this.nextElementSibling;
    
    // 開閉状態を切り替え
    if (content.style.maxHeight) {
        content.style.maxHeight = null; // 閉じる
    } else {
        content.style.maxHeight = content.scrollHeight + "px"; // 開く
    }
});
```

**重要なポイント**：
- `maxHeight`プロパティで高さを動的に制御
- `scrollHeight`で要素の実際の高さを取得
- CSSの`overflow: hidden`と組み合わせて使用

### イベント駆動型プログラミング

**JavaScriptのイベント概念**

JavaScriptでは「イベント」は、ウェブページやブラウザ上で発生する様々な「出来事」や「アクション」を指します。イベント駆動型プログラミングとは、これらのイベントに対して処理を定義するプログラミングスタイルです。

**主なイベントの種類：**

1. **ユーザーアクション系イベント:**
   - **クリックイベント**: ボタンやリンクがクリックされたとき
   - **マウスオーバーイベント**: マウスが要素の上に乗ったとき
   - **マウスアウトイベント**: マウスが要素から離れたとき
   - **キーダウンイベント**: キーボードのキーが押されたとき
   - **キーアップイベント**: キーボードのキーが離されたとき
   - **フォーカスイベント**: 入力フィールドなどにフォーカスが当たったとき

2. **ドキュメント系イベント:**
   - **ロードイベント**: ページが完全に読み込まれたとき
   - **DOMContentLoadedイベント**: HTMLドキュメントの読み込みと解析が完了したとき
   - **リサイズイベント**: ブラウザのウィンドウサイズが変更されたとき
   - **スクロールイベント**: ページがスクロールされたとき

3. **フォーム系イベント:**
   - **サブミットイベント**: フォームが送信されたとき
   - **チェンジイベント**: 入力内容が変更されたとき
   - **インプットイベント**: 入力フィールドの値が変更されたとき

**イベントリスナーの基本構文:**

```javascript
要素.addEventListener('イベント名', function() {
  // イベント発生時に実行する処理
});
```

**実際の例（アコーディオンメニュー）:**

```javascript
// ヘッダー要素を取得
const header = document.querySelector('.accordion-header');

// クリックイベントのリスナーを追加
header.addEventListener('click', function() {
  // ヘッダーがクリックされたときの処理
  const content = this.nextElementSibling;
  
  // コンテンツの表示/非表示を切り替え
  if (content.style.display === 'none') {
    content.style.display = 'block';
  } else {
    content.style.display = 'none';
  }
});
```

**重要ポイント:**
- イベントリスナーは「何かが起きたら〇〇する」という形で処理を定義する
- 一つの要素に複数のイベントリスナーを設定できる
- 同じイベントに対して複数の処理を設定することも可能
- イベントはHTMLが構築された後に登録するのが一般的（bodyタグの最後にJavaScriptを配置する理由）

## 【サジェスト機能の使い方】
### 基本的な使い方
- 文字を入力すると自動的に候補が表示される
- 候補の選択方法：
  - `Tab`キーで確定（最優先）
  - 矢印キー（↑↓）で選択し、`Enter`キーで確定
  - マウスでクリックして選択

### 手動で候補を表示する方法
- Mac: `Command + Space`
- Windows/Linux: `Ctrl + Space`

## 【HTMLのショートカット入力】

### Emmetショートカット
- `!` + `Tab` - HTML5の基本構造を自動生成
- `html:5` + `Tab` - 同じく基本構造生成

## Git・GitHub関連

### 基本用語
- リポジトリ：プロジェクトの保存場所。変更履歴も保存される賢いフォルダ
- プッシュ：ローカルのファイルをGitHubのリポジトリにアップロードすること
- ステージング：変更したファイルをコミット前に準備するプロセス。次のコミットに含めるファイルを指定する作業

### ステージングについて
- 目的：どのファイルの変更をコミットに含めるかを選択すること
- 実行方法：`git add <ファイル名>`

### node_modulesフォルダとGitHub

#### node_modulesをGitHubにアップロードすべきでない理由
1. **容量が大きすぎる**
   - 多くのライブラリと依存関係を含むため、サイズが非常に大きい（数百MB〜GB）
   - リポジトリのダウンロード・アップロード時間が増大する
   - GitHubのストレージ制限に達する可能性がある

2. **環境依存のファイルを含む**
   - OS固有のバイナリファイルが含まれる場合がある
   - 異なる開発環境で問題が発生する可能性がある

3. **リポジトリの管理が複雑になる**
   - 変更履歴が膨大になり、意味のある差分を確認しづらくなる
   - コミットサイズが大きくなりすぎて操作が遅くなる

#### 推奨される対処方法
1. `.gitignore`ファイルに`node_modules/`を追加する
2. 代わりに`package.json`と`package-lock.json`ファイルをコミットする
3. プロジェクトをクローンした後は`npm install`コマンドで依存関係をインストールする

#### .gitignoreの設定方法
```bash
# .gitignoreファイルがない場合は作成
touch .gitignore

# node_modules/を追加
echo "node_modules/" >> .gitignore

# もし既にステージングされていれば取り消す
git rm -r --cached node_modules
git add .gitignore
git commit -m "node_modulesをgitignoreに追加"
```

#### .gitignoreの効果
.gitignoreファイルにnode_modules/を追加すると、次からGitは自動的にそのフォルダを無視します。つまり：

- git statusを実行しても、node_modulesフォルダは「変更されたファイル」や「未追跡のファイル」として表示されなくなります
- git add .やgit add *のようなコマンドを実行しても、node_modulesフォルダは自動的にスキップされます
- 明示的にgit add node_modulesと指定しない限り、ステージングエリアに追加されることはありません

これはGitの基本機能で、.gitignoreに記載されたパターンに一致するファイルやフォルダは、Gitの追跡対象から自動的に除外されます。

一度設定すれば、今後意識することなく開発を続けられます。他の開発者がリポジトリをクローンした場合も、npm installコマンドでnode_modulesフォルダを再現できます。

#### 魔法（ライブラリ）の使い方
1. まず道具箱に追加する：`npm install 魔法の名前`
2. プログラムの中で「この魔法を使います！」と宣言する：`import { 使いたい魔法 } from '魔法の名前';`
3. あとは魔法を使うだけ！

#### 便利なポイント
- パソコンの中で直接JavaScriptが動かせる（ブラウザがなくても大丈夫！）
- 一度書いたプログラムは、いろんなパソコンで動かせる
- たくさんの便利な道具箱（ライブラリ）が使える

これでNode.jsの基本が分かったね！実際に使ってみると、もっと楽しくなるよ！

## 【2025/04/19】Web関連の基礎知識

### WebとWebサイト、Webページの関係
1. **Web（WWW）とは**
   - World Wide Webの略
   - インターネット上の情報共有の仕組み全体
   - 世界中の情報がハイパーリンクで繋がった巨大なネットワーク

2. **Webサイトとは**
   - 複数のWebページをまとめたもの
   - 例：私のGitHubリポジトリ（study_web）全体が1つのWebサイト
   - 特定のドメインで管理される
   - 本で例えると1冊の本全体

3. **Webページとは**
   - HTMLで作られた1つ1つの情報ページ
   - 例：私が作成した以下のようなページ
     - トップページ（index.html）
     - 自己紹介ページ（profile.html）
     - プロフィールカード（card.html）
     - アコーディオンメニューのページ（accordion.html）
   - 本で例えると1ページ分
   - practice/フォルダ内の各課題ファイルは、それぞれが独立したWebページ

### 実際の制作物での例
- **私のWebサイト（study_webリポジトリ）の構成**
  - 複数のWebページ（HTMLファイル）が集まって1つのWebサイトを形成
  - 各HTMLファイルは独立したWebページとして機能
  - これらすべてがWeb（WWW）という大きなネットワークの一部

### ポイント
- 個々のHTMLファイルは「Webページ」と呼んでよい
- 関連するWebページをまとめたものが「Webサイト」
- すべてのWebサイトは「Web（WWW）」という大きな仕組みの中に存在する

## 【2025/04/16】JavaScript基本構文とよくあるエラー

### 文字列操作で気をつけること
- JavaScriptでの文字列連結方法（2種類）：
  1. 「+」演算子による連結: `"文字列" + 変数 + "文字列"`
  2. テンプレートリテラルによる埋め込み: `` `文字列${変数}文字列` ``（バッククォート使用）
- **全角記号と半角記号の区別**：
  - 正しい（半角）: `"りんごの値段は" + (個数 * 100) + "円です"`
  - 誤り（全角）: `"りんごの値段は"＋（個数 * 100）＋"円です"`

### 関数定義と呼び出しのエラー
- 関数名と呼び出し名は完全に一致させる必要がある
  - 定義: `function 大きい数字(a, b) {...}`
  - 正しい呼び出し: `大きい数字(10, 5)`
  - 誤った呼び出し: `大きい方(10, 5)` → エラー発生

### 条件分岐の実装
- if文での条件式は論理的に正しく記述する：
  ```javascript
  // 正しい条件分岐（両方のケースを考慮）
  if (a > b) {
    return a + "の方が大きいです";
  } else {
    return b + "の方が大きいです"; 
  }
  
  // 誤った条件分岐（両方同じ条件）
  if (a < b) {
    return a + "の方が大きいです";
  } else if (a < b) {
    return b + "の方が大きいです";
  }
  ```

### 構文エラーのデバッグ手順
1. コンソールでエラーメッセージを確認
2. 行番号と具体的なエラー内容を特定
3. 記号（括弧、引用符、セミコロンなど）が半角か確認
4. 変数名と関数名が一致しているか確認
5. 文字列内の変数が正しく埋め込まれているか確認

### テンプレートリテラルの活用
```javascript
// 名前と年齢を表示する関数
function 自己紹介(名前, 年齢) {
  // テンプレートリテラルを使用（バッククォート）
  return `私の名前は${名前}です。${年齢}歳です。`;
}
```
## includes()メソッド

### 基本的な使い方
- 配列の中に特定の値が含まれているかをチェックするメソッド
- 結果は `true` または `false` を返す
- 書き方：`配列.includes(探したい値)`

### 使用例
```javascript
// 果物の配列
const fruits = ["りんご", "バナナ", "オレンジ"];

// チェック例
console.log(fruits.includes("りんご"));  // true  （含まれている）
console.log(fruits.includes("ぶどう"));  // false （含まれていない）
```

### if文での活用例
```javascript
// 31日ある月のリスト
const longMonths = ["1月","3月","5月","7月","8月","10月","12月"];

const month = "7月";
if (longMonths.includes(month)) {
    console.log(month + "は31日あります");
} else {
    console.log(month + "は31日以外の日数です");
}
```

### メリット
1. コードがシンプルで読みやすい
2. 複数の値との比較を1行で書ける
3. 配列の要素を簡単にチェックできる

### 注意点
- 大文字小文字は区別される（"Apple" と "apple" は別物として扱われる）
- 完全一致でチェックされる（部分一致は検出されない） 

## 配列メソッド

### メソッドとは？
- オブジェクトや配列が持っている特別な機能（関数）
- ドット（.）をつけて呼び出す
- 例：`配列.メソッド名()`

### 主な配列メソッド一覧

| メソッド名 | 説明 | 使用例 | 結果 |
|------------|------|--------|------|
| `includes()` | 配列に特定の要素が含まれているかを確認 | `["りんご", "みかん"].includes("りんご")` | `true` |
| `forEach()` | 配列の各要素に対して処理を実行 | `[1, 2, 3].forEach(num => console.log(num))` | 1, 2, 3を順に表示 |
| `push()` | 配列の末尾に要素を追加 | `fruits.push("バナナ")` | 配列の最後にバナナを追加 |
| `pop()` | 配列の末尾の要素を削除して返す | `fruits.pop()` | 最後の要素を削除して返す |
| `shift()` | 配列の先頭の要素を削除して返す | `fruits.shift()` | 最初の要素を削除して返す |
| `unshift()` | 配列の先頭に要素を追加 | `fruits.unshift("りんご")` | 配列の先頭にりんごを追加 |
| `slice()` | 配列の一部を切り出して新しい配列を作成 | `fruits.slice(1, 3)` | インデックス1から2までの要素を取得 |
| `join()` | 配列の要素を結合して文字列にする | `["a", "b", "c"].join("-")` | "a-b-c" |
| `map()` | 各要素に処理を適用して新しい配列を作成 | `[1, 2, 3].map(n => n * 2)` | `[2, 4, 6]` |
| `filter()` | 条件に合う要素だけを抽出して新しい配列を作成 | `[1, 2, 3].filter(n => n > 1)` | `[2, 3]` |

### メソッドの使い分けポイント
1. **要素の追加・削除**
   - 末尾の操作：`push()`/`pop()`
   - 先頭の操作：`unshift()`/`shift()`

2. **要素の検索・確認**
   - 存在確認：`includes()`
   - 条件検索：`filter()`

3. **要素の変換・加工**
   - 全要素の処理：`forEach()`
   - 新しい配列作成：`map()`
   - 文字列化：`join()`

4. **部分取り出し**
   - 範囲指定：`slice()`

### 使用例
```javascript
// 果物の配列
const fruits = ["りんご", "バナナ", "オレンジ"];

// forEach()で全要素を表示
fruits.forEach(fruit => console.log(fruit));

// includes()で存在確認
if (fruits.includes("りんご")) {
    console.log("りんごがあります！");
}

// map()で新しい配列作成
const fruitMessages = fruits.map(fruit => `${fruit}があります`);
``` 

## HTMLとCSS

### trタグとdivタグの適切な使い分け方 📝 2025/04/21

HTMLでテーブル（表）を作成する際と単純なレイアウト目的での要素の使い分け方について整理しました。

#### trタグの用途と特徴
- `<tr>` (table row)はテーブル（`<table>`）内で行を表現するための専用タグ
- 必ず`<table>`の中で使用する必要がある
- `<tr>`の中には`<td>`（テーブルデータ）や`<th>`（テーブルヘッダー）要素を配置する
- 表形式のデータを表現する時に適している
- テーブルのセマンティクス（意味構造）を正しく表現できる

```html
<table>
  <tr>
    <th>ヘッダー1</th>
    <th>ヘッダー2</th>
  </tr>
  <tr>
    <td>データ1</td>
    <td>データ2</td>
  </tr>
</table>
```

#### divタグの用途と特徴
- `<div>`はブロックレベル要素を作る汎用的なコンテナ
- レイアウトの区切りや、スタイルを適用するためのグループ化に使用
- 意味的な構造を持たないため、純粋にレイアウト目的に適している
- CSSと組み合わせて柔軟なデザインが可能

```html
<div class="container">
  <div class="row">
    <div class="cell">データ1</div>
    <div class="cell">データ2</div>
  </div>
</div>
```

#### 使い分けのポイント
1. **データの性質を考慮**: 表形式のデータを表示する場合は`<table>`を使用
2. **アクセシビリティ**: スクリーンリーダーなどの支援技術を使用するユーザーのために、データの構造を正しく伝えるためにも適切な要素を選択する
3. **レスポンシブデザイン**: 単純なレイアウト目的なら`<div>`の方が柔軟に対応できる

#### 注意点
- 昔はテーブルレイアウト（`<table>`を使ったページのレイアウト）が一般的だったが、現在はCSSを使った方法が推奨されている
- SEOの観点からも、適切な要素を使うことが重要

### マークダウンでの画像表示と調整方法
### マークダウンでの画像表示と調整方法 📝 2025/04/21

マークダウンでは通常、以下の形式で画像を挿入します：

```markdown
![代替テキスト](画像のURL "オプションのタイトル")
```

しかし、サイズ調整やセンタリングなどの細かい制御が必要な場合は、HTMLタグを使用することができます。

#### 画像サイズの調整
```html
<img src="画像のパス" width="300" height="200" alt="代替テキスト">
```

#### 画像の中央揃え
```html
<div align="center">
  <img src="画像のパス" alt="代替テキスト">
</div>
```

#### 画像にリンクを設定
```markdown
[![代替テキスト](画像のパス)](リンク先URL)
```

#### スタイルを適用した画像
```html
<img src="画像のパス" alt="代替テキスト" style="border: 1px solid #ddd; border-radius: 8px; padding: 5px;">
```

#### 画像のフロート（テキスト回り込み）
```html
<img src="画像のパス" alt="代替テキスト" style="float: right; margin: 0 0 10px 10px;">
テキストがここに入ります。画像は右側に配置され、テキストが画像の周りに回り込みます。
<div style="clear: both;"></div><!-- フロートのクリア -->
```

#### 注意点
- GitHubやNotion等のプラットフォームでは、セキュリティ上の理由からHTMLタグの一部が制限されていることがある
- マークダウンの実装によって、対応しているHTMLタグやCSSプロパティが異なる場合がある
- 複雑なレイアウトが必要な場合は、純粋なHTMLドキュメントを作成した方が柔軟性が高い 

## ビューポートメタタグ
### ビューポートメタタグの役割と設定方法
```html
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

この設定は2つの重要な部分から成ります：

1. **width=device-width**
   - ページの幅をデバイスの画面幅に合わせる
   - 様々な画面サイズのデバイスで適切に表示される

2. **initial-scale=1.0**
   - 初期表示時のズームレベルを100%（等倍）に設定
   - ページが拡大・縮小されずにそのままの比率で表示される

**重要性**：
- モバイルデバイスでの適切な表示を保証
- レスポンシブデザインの基盤となる設定
- ユーザーが拡大操作なしでコンテンツを閲覧できる
- メディアクエリと組み合わせて異なる画面サイズに対応

## 箇条書きのインデント調整
### 箇条書きの2行目以降を揃える方法（2025/04/21）
- 問題点
  - 箇条書きの2行目以降がマーク（・）よりも左に揃ってしまう
  - 長文の場合、テキストが左端から始まるため読みにくくなる
  
- 解決方法：text-indentプロパティの活用
  ```css
  li {
    padding-left: 1.5em;  /* マークより右側にテキスト全体を配置 */
    text-indent: -1.5em;  /* 最初の行だけ左にずらす（マークを表示） */
  }
  ```
  
- 仕組みの解説
  1. `padding-left: 1.5em;` でリスト全体を右側にずらす
  2. `text-indent: -1.5em;` で最初の行だけ左に戻す（負の値）
  3. 結果として、マークは元の位置に、2行目以降はマークの右に揃う
  
- 応用例（カスタム箇条書き）
  ```css
  .custom-list {
    list-style: none;  /* 標準の箇条書きマークを非表示 */
  }
  
  .custom-list li {
    padding-left: 1.4em;
    text-indent: -1.4em;
  }
  
  .custom-list li:before {
    content: "✓";  /* カスタムマーク */
    margin-right: 0.4em;
  }
  ```
  
- 注意点
  - padding-leftとtext-indentの値は一致させるのが基本
  - emやremなどの相対単位を使うと、フォントサイズが変わっても調整される
  - ネストされたリストでは、階層ごとに異なる値を設定すると良い

## CSSプロパティの継承に関する注意点 📝
### 継承されるプロパティと継承されないプロパティ（2025/04/21）
- 継承されるプロパティ（親要素から子要素に自動的に引き継がれる）
  - `color` - テキストの色
  - `font-family` - フォントの種類
  - `font-size` - フォントサイズ
  - `font-weight` - フォントの太さ
  - `line-height` - 行の高さ
  - `text-align` - テキストの配置
  - `visibility` - 表示/非表示（スペースは維持）
  
- 継承されないプロパティ（子要素に自動的に引き継がれない）
  - `margin`, `padding` - 余白関連
  - `border` - 境界線
  - `background` - 背景
  - `width`, `height` - サイズ
  - `position` - 配置方法
  - `display` - 表示形式
  - `z-index` - 重ね順
  
- 継承を制御するための値
  - `inherit` - 親要素の値を強制的に継承させる
  - `initial` - ブラウザの初期値に戻す
  - `unset` - 継承するプロパティは継承し、しないプロパティは初期値に戻す
  
- 実用例
  ```css
  /* すべてのボタンに親要素のフォントカラーを継承させる */
  button {
    color: inherit;
  }
  
  /* ボックスの背景色を強制的にリセットする */
  .reset-box {
    background-color: initial;
  }
  ```
  
- 注意点
  - 継承は直接の親だけでなく、先祖要素からも引き継がれる
  - CSSの詳細度（セレクタの強さ）によって継承よりも強いルールが適用される場合がある
  - `!important`を使うと継承よりも優先される

## transformプロパティのアニメーション 📝
### transform: rotate()を使った要素の回転（2025/04/21）
- 基本構文
  ```css
  .element {
    transform: rotate(90deg); /* 時計回りに90度回転 */
    transition: transform 0.5s; /* 0.5秒かけて回転するアニメーション */
  }
  ```
- 主な回転値
  - `rotate(45deg)` - 時計回りに45度回転
  - `rotate(-90deg)` - 反時計回りに90度回転
  - `rotate(0.5turn)` - 180度回転（turnは1回転を表す単位）
- 回転の中心点の変更
  ```css
  .element {
    transform-origin: top left; /* 左上を中心に回転 */
    transform: rotate(45deg);
  }
  ```
- 実用例：ボタン内の矢印アイコンを回転
  ```css
  .accordion-header.active .arrow {
    transform: rotate(180deg); /* アコーディオンが開いたときに矢印を回転 */
  }
  ```
- 注意点
  - 回転は要素の表示位置を変えるだけで、ドキュメントのレイアウトには影響しない
  - 3D回転をするには `rotateX()`, `rotateY()`, `rotateZ()` を使用する

## 【CSS関連】

### CSS基本プロパティと使い方

#### ホバー効果とカーソルプロパティ

**ホバー（:hover）疑似クラス**

ホバーとは、マウスカーソルを要素の上に置いた状態のことです。CSSでは`:hover`疑似クラスを使用して、この状態の時のスタイルを指定できます。

**基本的な使い方:**
```css
.button:hover {
  background-color: blue;  /* ホバー時は背景色が青に変わる */
}
```

#### CSS擬似要素（::before, ::after）

擬似要素とは「HTMLには書いていないけど、CSSだけで追加できる架空の要素」のことです。HTMLを変更せずにCSSだけで内容を追加できる強力な機能です。

**主な擬似要素:**
- **::before** - 要素の中身の前に何かを追加
- **::after** - 要素の中身の後に何かを追加

**基本的な使い方:**
```css
.example::before {
  content: "★"; /* 必須プロパティ。挿入する内容を指定 */
  color: red;    /* 通常の要素と同様にスタイリングできる */
}

.example::after {
  content: "☆";
  margin-left: 5px;
}
```

**実用例（アコーディオンメニューの+/-アイコン）:**
```css
.accordion-header::after {
  content: '+';   /* + 記号を挿入 */
  float: right;   /* 右側に配置 */
}

/* アクティブ状態では - 記号に変更 */
.accordion-header.active::after {
  content: '-';
}
```

**擬似要素を使うメリット:**
1. HTMLをシンプルに保てる（装飾目的のタグが減る）
2. JavaScriptを使わずにデザイン的な効果が得られる
3. 内容とデザインの分離がしやすくなる

#### marginプロパティの詳細

`margin`プロパティは要素の外側の余白（マージン）を設定するためのCSSプロパティです。

**値の指定方法:**

1. **一括指定**
   - `margin: 10px;` - 上下左右すべての余白を10pxに設定

2. **方向別の指定**
   - `margin-top`, `margin-right`, `margin-bottom`, `margin-left` - 各方向の余白を個別に指定

3. **省略記法（ショートハンド）**
   - `margin: 上 右 下 左;` - 時計回りで4つの値を指定
   - `margin: 上下 左右;` - 2つの値を指定（上下共通、左右共通）
   - `margin: 上 左右 下;` - 3つの値を指定（左右は共通）

**特別な値:**

1. **`auto`** - ブラウザによる自動計算
   - `margin: 0 auto;` - 上下マージンは0、左右マージンは自動計算により中央揃えを実現
   - 要素に幅（width）が設定されている場合に有効
   - ブロックレベル要素の水平中央配置に広く使用される
   - `<div>`, `<p>`, `<section>`などの要素を中央揃えにする際に便利

2. **負の値** - 要素を通常の配置位置から反対方向に移動させる
   - `margin-top: -20px;` - 要素を上方向に20px移動

**使用例と実践的なパターン:**

```css
/* コンテンツを中央揃えにするコンテナ */
.container {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto; /* 上下余白なし、左右自動で中央揃え */
}

/* カードデザインの余白設定 */
.card {
  margin: 20px; /* 全方向に20pxの余白 */
}

/* 段落間の間隔設定 */
p {
  margin: 0 0 1em 0; /* 上:0、右:0、下:1em、左:0 */
}
```

**注意点:**

- 複数要素間のマージンは「マージンの相殺（Margin Collapse）」が発生することがある（上下方向のみ）
- 特に垂直方向のレイアウトでは、隣接する要素同士のマージンは大きい方の値が採用される
- インライン要素には左右のマージンのみ適用され、上下のマージンは無視される

#### max-widthプロパティの詳細

`max-width`プロパティは要素の最大幅を制限するためのCSSプロパティです。要素は通常、親要素や内容に基づいて幅が決まりますが、`max-width`を設定すると指定した値以上に広がらなくなります。

**主な特徴と使い方:**

1. **レスポンシブデザインでの活用**
   - 大きな画面では幅を制限し、小さな画面では`width: 100%`と組み合わせて画面幅に合わせる
   - `max-width: 1200px;` - 画面が1200pxより広くても、要素は1200px以上に広がらない
   - `width: 100%;` と組み合わせると、小さな画面では画面いっぱいに、大きな画面では制限された幅で表示

2. **コンテンツの読みやすさの向上**
   - テキストコンテンツは行の長さが適切な範囲内（約50〜75文字）だと読みやすい
   - `max-width: 800px;` - 本文コンテナなどに設定し、行の長さを適切に保つ

3. **メディア要素の制御**
   - 画像やビデオが親要素からはみ出すのを防ぐ
   - `max-width: 100%;` - 画像やビデオを親要素より大きくならないように制限（レスポンシブイメージの基本テクニック）

**実用的な使用例:**

```css
/* レスポンシブなメインコンテナ */
.main-container {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
}

/* 読みやすい本文エリア */
.article-content {
  width: 100%;
  max-width: 800px;
  margin: 0 auto;
}

/* レスポンシブな画像 */
img {
  max-width: 100%;
  height: auto;
}
```

**max-widthとwidthの違い:**

- `width` - 要素の固定幅を設定
- `max-width` - 要素が広がる最大値を制限するが、画面が小さくなると自動的に縮小

**他の関連プロパティ:**

- `min-width` - 要素の最小幅を設定
- `width` - 要素の幅を設定
- `max-height` - 要素の最大高さを設定
- `min-height` - 要素の最小高さを設定

**レスポンシブデザインでの典型的なパターン:**

```css
.container {
  width: 100%;      /* 小さい画面では画面幅いっぱいに広がる */
  max-width: 500px; /* 大きい画面では500pxを超えない */
  margin: 0 auto;   /* 中央揃え */
}
```

**このパターンの効果:**
- モバイル画面ではコンテナが画面幅いっぱいに表示される
- 画面が広くなるにつれてコンテナも広がるが、500pxを超えることはない
- 画面幅が500pxを超えると、コンテナは中央に配置される

**ポイント:**
- レスポンシブデザインの基本テクニック
- 異なる画面サイズでの一貫したユーザー体験を提供
- モバイルファーストの設計アプローチと相性が良い

#### overflow: hidden
ボックスからはみ出た内容を非表示にするプロパティ。
- アコーディオンメニューでは閉じた時に内容を完全に隠す
- メニューの開閉アニメーションをきれいに見せるために必要
- 値：visible（表示）、hidden（非表示）、scroll（常にスクロール）、auto（必要時スクロール）

#### リセットスタイル
ブラウザの標準スタイル設定をリセットするためのCSSコード。
- `margin: 0;` - すべての余白をゼロに
- `padding: 0;` - すべての内部余白をゼロに
- `box-sizing: border-box;` - ボーダーとパディングを幅と高さに含める

#### フォントフォールバック
`font-family: 'Helvetica Neue', Arial, sans-serif;`
- 左から順に適用を試みる（最初がなければ次を使用）
- 最後は必ずジェネリックファミリー（sans-serif等）を指定

#### Flexboxレイアウト
要素を柔軟に配置・整列させるための仕組み。
- `display: flex;` - フレックスボックスレイアウト
- `justify-content: center;` - 水平方向の配置
- `align-items: center;` - 垂直方向の配置
- `flex-direction: row/column;` - 並ぶ方向

### displayプロパティの詳細

`display`プロパティはHTML要素の表示方法を指定する最も基本的なCSSプロパティです。

#### 主な値と効果:

1. **`display: block`**
   - 要素が1行全体を占有する
   - 幅と高さを指定可能
   - `<div>`, `<p>`, `<h1>`などはデフォルトでblock
   - 前後に自動的に改行が入る

2. **`display: inline`**
   - テキストの流れに沿って表示される
   - 幅と高さを直接指定できない
   - `<span>`, `<a>`, `<strong>`などはデフォルトでinline
   - 改行なしで横に並ぶ

3. **`display: inline-block`**
   - inlineとblockの特性を組み合わせたもの
   - 横に並ぶが、幅と高さを指定できる
   - フォームの要素などによく使われる

4. **`display: none`**
   - 要素を完全に非表示にする
   - レイアウトにも影響しない（スペースも占有しない）
   - JavaScriptで動的に表示/非表示の切り替えに使用

5. **`display: flex`**
   - 要素をフレックスコンテナに変換する
   - 子要素（フレックスアイテム）を柔軟にレイアウト可能
   - 一次元のレイアウト（横または縦の一方向）に最適
   - モバイルフレンドリーなレスポンシブデザインに適している

6. **`display: grid`**
   - 要素をグリッドコンテナに変換する
   - 行と列の二次元レイアウトを実現
   - 複雑なレイアウトを簡潔に記述可能
   - グリッドラインに基づいた正確な配置が可能

7. **`display: table`系**
   - HTMLのテーブル要素と同様の表示形式
   - `table`, `table-row`, `table-cell`などの値がある
   - 表形式のレイアウトを実現できるが、現在はflexやgridの利用が推奨

### align-itemsプロパティの詳細

`align-items`プロパティはFlexboxとGridレイアウトにおいて、コンテナ内の子要素をクロスアクシス（交差軸）上でどのように配置するかを指定します。Flexboxのデフォルト設定でクロスアクシスは縦方向（垂直方向）です。

#### 主な値と効果:

1. **`align-items: stretch`** (デフォルト値)
   - 子要素をコンテナの高さいっぱいに引き伸ばす
   - 子要素の高さが明示的に指定されていない場合のみ有効
   - サイドバーとメインコンテンツを同じ高さにするのに便利

2. **`align-items: flex-start`**
   - 子要素をクロスアクシスの開始位置（上端）に配置
   - 異なる高さの要素が上端で揃う
   - ヘッダーなどのトップに揃えたい場合に使用

3. **`align-items: flex-end`**
   - 子要素をクロスアクシスの終了位置（下端）に配置
   - 異なる高さの要素が下端で揃う
   - フッターなどの下部に揃えたい場合に使用

4. **`align-items: center`**
   - 子要素をクロスアクシスの中央に配置
   - 垂直方向の中央揃えを実現
   - ナビゲーションバーやモーダルウィンドウの中央配置に最適

5. **`align-items: baseline`**
   - 子要素のテキストのベースライン（文字の下線）で揃える
   - 異なるフォントサイズのテキストを綺麗に整列させるのに有効
   - タイポグラフィを重視するデザインで役立つ

**使用例:**

```css
/* 縦方向に中央揃えのナビゲーションバー */
.navbar {
  display: flex;
  height: 80px;
  align-items: center;
}

/* カードの内容を上部に揃える */
.card-container {
  display: flex;
  align-items: flex-start;
}

/* 全ての子要素を同じ高さにする */
.sidebar {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
```

**ポイント:**
- `flex-direction: column`を使用すると、メインアクシスと交差アクシスが入れ替わるため、`align-items`の効果も横方向に変わる
- Grid内での`align-items`はグリッドセル内の要素の配置を制御する
- `align-content`プロパティと混同しないこと（`align-content`は複数行にわたるフレックスアイテム全体の配置を制御）

### よく使われるFlexboxの組み合わせパターン

```css
.container {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
```

**詳細説明**:

1. **`display: flex`**
   - 対象の要素をフレックスコンテナに変換する
   - 子要素（フレックスアイテム）は初期設定で横並びになる
   - フレックスアイテムは自動的に伸縮し、親コンテナの領域に合わせて調整される
   - ブロック要素でもインライン要素でも適用可能

2. **`justify-content: space-between`**
   - メインアクシス（横方向）に沿った配置を指定
   - `space-between`は最初の要素を左端、最後の要素を右端に配置し、残りの要素を均等に分散
   - 子要素間の空白が均等になるよう自動調整される
   - 他の値: `flex-start`（左揃え）、`flex-end`（右揃え）、`center`（中央揃え）、`space-around`（周囲の余白均等）など

3. **`align-items: center`**
   - クロスアクシス（縦方向）に沿った配置を指定
   - `center`は子要素を縦方向の中央に配置
   - コンテナの高さより子要素の高さが小さい場合に、その効果が顕著に表れる
   - 他の値: `flex-start`（上揃え）、`flex-end`（下揃え）、`stretch`（親に合わせて伸縮）、`baseline`（ベースラインで揃える）

**このパターンの一般的な使用例**:
- ナビゲーションバー: ロゴを左、メニューを右に配置
- アコーディオンヘッダー: タイトルを左、開閉アイコンを右に配置
- カード内のフッター: 「詳細」ボタンを左、「いいね」ボタンを右に配置
- フォーム要素: ラベルを左、入力フィールドを右に配置

**ポイント**:
- 直感的で簡単に両端揃えと垂直中央揃えが実現できる
- レスポンシブデザインと相性が良い
- 従来のfloatやpositionを使った複雑なレイアウトよりもはるかに簡潔に記述できる
- ブラウザ互換性が高い（IE11以降、他の主要ブラウザは全て対応）

#### CSSの優先順位
1. 詳細度が高いセレクタが優先（インラインスタイル > ID > クラス > 要素）
2. 同じ詳細度なら後に書かれたスタイルが優先
3. !important指定は最優先（使用は避ける）

#### パディング指定
- 個別：`padding-top/right/bottom/left`
- 4値：`padding: 上 右 下 左`（時計回り）
- 3値：`padding: 上 右左 下`
- 2値：`padding: 上下 右左`
- 1値：`padding: 全方向`

### width設定のポイント

#### 基本的な考え方
1. **コンテンツに適した幅を選ぶ**
   - テキスト中心なら600〜700px程度（日本語20〜40文字が読みやすい）
   - 画像やリッチコンテンツなら必要に応じて広く

2. **レスポンシブデザインを考慮**
   - モバイル：画面幅の90〜100%
   - デスクトップ：最大幅（max-width）を設定

3. **基本的な設定方法**
   ```css
   .element {
     width: 90%;          /* 親要素の90% */
     max-width: 700px;    /* 最大幅を制限 */
     margin: 0 auto;      /* 中央揃え */
   }
   ```

#### 実用的なテクニック
- **コンテナ要素**には`max-width`で上限を設定
- **中身の要素**には`width: 100%`で親に合わせる
- `box-sizing: border-box`を使うとpadding/borderを含めた幅指定ができる

#### 注意点
- 幅が広すぎると行長が長くなり読みにくい
- 狭すぎると改行が多くなり不自然
- ユーザーの視線移動と画面サイズを考慮する

### 内部CSSの配置

HTMLファイル内で`<style>`タグを使って直接CSSコードを記述する場合、適切な配置場所は`<head>`タグの中で、特に終了直前が推奨されます。

**正しい配置順序:**
1. 文字コード設定: `<meta charset="UTF-8">`
2. ビューポート設定: `<meta name="viewport">`
3. タイトル情報: `<title>`
4. 外部CSSファイル: `<link rel="stylesheet">`
5. 内部CSS: `<style>` タグ

**コード例:**
```html
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ページタイトル</title>
  <link rel="stylesheet" href="external.css">
  <style>
    /* 内部CSS */
    body {
      font-family: sans-serif;
    }
    .container {
      margin: 0 auto;
    }
  </style>
</head>
```

**ポイント:**
- 基本情報（文字コードなど）を先に読み込んでから、スタイル情報を読み込む
- 外部CSSファイルを先に読み込み、内部CSSで上書きや調整ができるようにする
- 優先順位の関係上、同じセレクタの場合は後に記述されたスタイルが適用される

### インラインスタイル

HTMLの要素に直接`style`属性としてCSSを記述する方法です。

**基本構文:**
```html
<要素名 style="プロパティ1: 値1; プロパティ2: 値2;">コンテンツ</要素名>
```

**実例:**
```html
<body style="max-width: 800px; margin: 0 auto; padding: 20px; font-family: sans-serif;">
```

**特徴:**
- その要素だけに適用されるスタイルを定義できる
- 他のCSSスタイル（内部CSSや外部CSS）よりも優先度が高い
- HTMLとCSSが混在するため、コードの管理が難しくなることがある
- 同じスタイルを複数の要素に適用したい場合は非効率

**使い分け:**
- 1回限りの特別なスタイル適用に適している
- プロトタイプ作成や簡単なデモページに便利
- 大規模サイトでは保守性の観点から避けるべき
- JavaScriptでスタイルを動的に変更する場合にも使用される

**CSS適用方法の比較:**
1. インラインスタイル: 個別要素に直接記述（優先度最高）
2. 内部CSS: ページ内の複数要素に適用（`<head>`内の`<style>`タグ）
3. 外部CSS: 複数ページに適用（別ファイルを`<link>`で読み込み）

### CSSセレクタの種類

#### 要素セレクタとクラスセレクタの違い

CSSでは様々な方法で装飾対象を指定できますが、主に以下の2種類のセレクタが基本となります：

**要素セレクタ**
- HTMLタグを直接指定するセレクタ
- ピリオド（.）は付けません
- 例：`body { }`, `footer { }`, `h1 { }`
- 該当するHTML要素全てにスタイルが適用されます
- `body { background-color: white; }` はページ全体の背景色を白に設定

**クラスセレクタ**
- class属性を持つ要素を指定するセレクタ
- ピリオド（.）を先頭に付ける必要があります
- 例：`.main-container { }`, `.accordion-item { }`
- 特定のクラス名を持つ要素のみにスタイルが適用されます
- `.active { color: red; }` は`class="active"`を持つ要素のテキストを赤色に設定

**実践的な使い方：**
```css
/* 要素セレクタ - 全てのh1要素に適用 */
h1 {
  font-size: 24px;
  color: #333;
}

/* クラスセレクタ - class="highlight"を持つ全ての要素に適用 */
.highlight {
  background-color: yellow;
  padding: 5px;
}

/* 要素とクラスの組み合わせ - class="special"を持つh2要素のみに適用 */
h2.special {
  border-bottom: 2px solid blue;
}
```

**セレクタ選択の基準：**
- 全てのページ要素に共通スタイルを適用する場合 → 要素セレクタ
- 特定の要素群だけに限定したスタイルを適用する場合 → クラスセレクタ
- 細かく制御したい場合は、クラスセレクタの方が一般的に適しています

## 【JavaScript関連】

### アコーディオンメニューの開閉制御
```javascript
// アコーディオンメニュー制御
accordionHeader.addEventListener('click', function() {
    // コンテンツ部分を取得
    const content = this.nextElementSibling;
    
    // 開閉状態を切り替え
    if (content.style.maxHeight) {
        content.style.maxHeight = null; // 閉じる
    } else {
        content.style.maxHeight = content.scrollHeight + "px"; // 開く
    }
});
```

**重要なポイント**：
- `maxHeight`プロパティで高さを動的に制御
- `scrollHeight`で要素の実際の高さを取得
- CSSの`overflow: hidden`と組み合わせて使用

### イベント駆動型プログラミング

**JavaScriptのイベント概念**

JavaScriptでは「イベント」は、ウェブページやブラウザ上で発生する様々な「出来事」や「アクション」を指します。イベント駆動型プログラミングとは、これらのイベントに対して処理を定義するプログラミングスタイルです。

**主なイベントの種類：**

1. **ユーザーアクション系イベント:**
   - **クリックイベント**: ボタンやリンクがクリックされたとき
   - **マウスオーバーイベント**: マウスが要素の上に乗ったとき
   - **マウスアウトイベント**: マウスが要素から離れたとき
   - **キーダウンイベント**: キーボードのキーが押されたとき
   - **キーアップイベント**: キーボードのキーが離されたとき
   - **フォーカスイベント**: 入力フィールドなどにフォーカスが当たったとき

2. **ドキュメント系イベント:**
   - **ロードイベント**: ページが完全に読み込まれたとき
   - **DOMContentLoadedイベント**: HTMLドキュメントの読み込みと解析が完了したとき
   - **リサイズイベント**: ブラウザのウィンドウサイズが変更されたとき
   - **スクロールイベント**: ページがスクロールされたとき

3. **フォーム系イベント:**
   - **サブミットイベント**: フォームが送信されたとき
   - **チェンジイベント**: 入力内容が変更されたとき
   - **インプットイベント**: 入力フィールドの値が変更されたとき

**イベントリスナーの基本構文:**

```javascript
要素.addEventListener('イベント名', function() {
  // イベント発生時に実行する処理
});
```

**実際の例（アコーディオンメニュー）:**

```javascript
// ヘッダー要素を取得
const header = document.querySelector('.accordion-header');

// クリックイベントのリスナーを追加
header.addEventListener('click', function() {
  // ヘッダーがクリックされたときの処理
  const content = this.nextElementSibling;
  
  // コンテンツの表示/非表示を切り替え
  if (content.style.display === 'none') {
    content.style.display = 'block';
  } else {
    content.style.display = 'none';
  }
});
```

**重要ポイント:**
- イベントリスナーは「何かが起きたら〇〇する」という形で処理を定義する
- 一つの要素に複数のイベントリスナーを設定できる
- 同じイベントに対して複数の処理を設定することも可能
- イベントはHTMLが構築された後に登録するのが一般的（bodyタグの最後にJavaScriptを配置する理由）

## 【サジェスト機能の使い方】
### 基本的な使い方
- 文字を入力すると自動的に候補が表示される
- 候補の選択方法：
  - `Tab`キーで確定（最優先）
  - 矢印キー（↑↓）で選択し、`Enter`キーで確定
  - マウスでクリックして選択

### 手動で候補を表示する方法
- Mac: `Command + Space`
- Windows/Linux: `Ctrl + Space`

## 【HTMLのショートカット入力】

### Emmetショートカット
- `!` + `Tab` - HTML5の基本構造を自動生成
- `html:5` + `Tab` - 同じく基本構造生成

## Git・GitHub関連

### 基本用語
- リポジトリ：プロジェクトの保存場所。変更履歴も保存される賢いフォルダ
- プッシュ：ローカルのファイルをGitHubのリポジトリにアップロードすること
- ステージング：変更したファイルをコミット前に準備するプロセス。次のコミットに含めるファイルを指定する作業

### ステージングについて
- 目的：どのファイルの変更をコミットに含めるかを選択すること
- 実行方法：`git add <ファイル名>`

### node_modulesフォルダとGitHub

#### node_modulesをGitHubにアップロードすべきでない理由
1. **容量が大きすぎる**
   - 多くのライブラリと依存関係を含むため、サイズが非常に大きい（数百MB〜GB）
   - リポジトリのダウンロード・アップロード時間が増大する
   - GitHubのストレージ制限に達する可能性がある

2. **環境依存のファイルを含む**
   - OS固有のバイナリファイルが含まれる場合がある
   - 異なる開発環境で問題が発生する可能性がある

3. **リポジトリの管理が複雑になる**
   - 変更履歴が膨大になり、意味のある差分を確認しづらくなる
   - コミットサイズが大きくなりすぎて操作が遅くなる

#### 推奨される対処方法
1. `.gitignore`ファイルに`node_modules/`を追加する
2. 代わりに`package.json`と`package-lock.json`ファイルをコミットする
3. プロジェクトをクローンした後は`npm install`コマンドで依存関係をインストールする

#### .gitignoreの設定方法
```bash
# .gitignoreファイルがない場合は作成
touch .gitignore

# node_modules/を追加
echo "node_modules/" >> .gitignore

# もし既にステージングされていれば取り消す
git rm -r --cached node_modules
git add .gitignore
git commit -m "node_modulesをgitignoreに追加"
```

#### .gitignoreの効果
.gitignoreファイルにnode_modules/を追加すると、次からGitは自動的にそのフォルダを無視します。つまり：

- git statusを実行しても、node_modulesフォルダは「変更されたファイル」や「未追跡のファイル」として表示されなくなります
- git add .やgit add *のようなコマンドを実行しても、node_modulesフォルダは自動的にスキップされます
- 明示的にgit add node_modulesと指定しない限り、ステージングエリアに追加されることはありません

これはGitの基本機能で、.gitignoreに記載されたパターンに一致するファイルやフォルダは、Gitの追跡対象から自動的に除外されます。

一度設定すれば、今後意識することなく開発を続けられます。他の開発者がリポジトリをクローンした場合も、npm installコマンドでnode_modulesフォルダを再現できます。

#### 魔法（ライブラリ）の使い方
1. まず道具箱に追加する：`npm install 魔法の名前`
2. プログラムの中で「この魔法を使います！」と宣言する：`import { 使いたい魔法 } from '魔法の名前';`
3. あとは魔法を使うだけ！

#### 便利なポイント
- パソコンの中で直接JavaScriptが動かせる（ブラウザがなくても大丈夫！）
- 一度書いたプログラムは、いろんなパソコンで動かせる
- たくさんの便利な道具箱（ライブラリ）が使える

これでNode.jsの基本が分かったね！実際に使ってみると、もっと楽しくなるよ！

## 【2025/04/19】Web関連の基礎知識

### WebとWebサイト、Webページの関係
1. **Web（WWW）とは**
   - World Wide Webの略
   - インターネット上の情報共有の仕組み全体
   - 世界中の情報がハイパーリンクで繋がった巨大なネットワーク

2. **Webサイトとは**
   - 複数のWebページをまとめたもの
   - 例：私のGitHubリポジトリ（study_web）全体が1つのWebサイト
   - 特定のドメインで管理される
   - 本で例えると1冊の本全体

3. **Webページとは**
   - HTMLで作られた1つ1つの情報ページ
   - 例：私が作成した以下のようなページ
     - トップページ（index.html）
     - 自己紹介ページ（profile.html）
     - プロフィールカード（card.html）
     - アコーディオンメニューのページ（accordion.html）
   - 本で例えると1ページ分
   - practice/フォルダ内の各課題ファイルは、それぞれが独立したWebページ

### 実際の制作物での例
- **私のWebサイト（study_webリポジトリ）の構成**
  - 複数のWebページ（HTMLファイル）が集まって1つのWebサイトを形成
  - 各HTMLファイルは独立したWebページとして機能
  - これらすべてがWeb（WWW）という大きなネットワークの一部

### ポイント
- 個々のHTMLファイルは「Webページ」と呼んでよい
- 関連するWebページをまとめたものが「Webサイト」
- すべてのWebサイトは「Web（WWW）」という大きな仕組みの中に存在する

## 【2025/04/16】JavaScript基本構文とよくあるエラー

### 文字列操作で気をつけること
- JavaScriptでの文字列連結方法（2種類）：
  1. 「+」演算子による連結: `"文字列" + 変数 + "文字列"`
  2. テンプレートリテラルによる埋め込み: `` `文字列${変数}文字列` ``（バッククォート使用）
- **全角記号と半角記号の区別**：
  - 正しい（半角）: `"りんごの値段は" + (個数 * 100) + "円です"`
  - 誤り（全角）: `"りんごの値段は"＋（個数 * 100）＋"円です"`

### 関数定義と呼び出しのエラー
- 関数名と呼び出し名は完全に一致させる必要がある
  - 定義: `function 大きい数字(a, b) {...}`
  - 正しい呼び出し: `大きい数字(10, 5)`
  - 誤った呼び出し: `大きい方(10, 5)` → エラー発生

### 条件分岐の実装
- if文での条件式は論理的に正しく記述する：
  ```javascript
  // 正しい条件分岐（両方のケースを考慮）
  if (a > b) {
    return a + "の方が大きいです";
  } else {
    return b + "の方が大きいです"; 
  }
  
  // 誤った条件分岐（両方同じ条件）
  if (a < b) {
    return a + "の方が大きいです";
  } else if (a < b) {
    return b + "の方が大きいです";
  }
  ```

### 構文エラーのデバッグ手順
1. コンソールでエラーメッセージを確認
2. 行番号と具体的なエラー内容を特定
3. 記号（括弧、引用符、セミコロンなど）が半角か確認
4. 変数名と関数名が一致しているか確認
5. 文字列内の変数が正しく埋め込まれているか確認

### テンプレートリテラルの活用
```javascript
// 名前と年齢を表示する関数
function 自己紹介(名前, 年齢) {
  // テンプレートリテラルを使用（バッククォート）
  return `私の名前は${名前}です。${年齢}歳です。`;
}
```
## includes()メソッド

### 基本的な使い方
- 配列の中に特定の値が含まれているかをチェックするメソッド
- 結果は `true` または `false` を返す
- 書き方：`配列.includes(探したい値)`

### 使用例
```javascript
// 果物の配列
const fruits = ["りんご", "バナナ", "オレンジ"];

// チェック例
console.log(fruits.includes("りんご"));  // true  （含まれている）
console.log(fruits.includes("ぶどう"));  // false （含まれていない）
```

### if文での活用例
```javascript
// 31日ある月のリスト
const longMonths = ["1月","3月","5月","7月","8月","10月","12月"];

const month = "7月";
if (longMonths.includes(month)) {
    console.log(month + "は31日あります");
} else {
    console.log(month + "は31日以外の日数です");
}
```

### メリット
1. コードがシンプルで読みやすい
2. 複数の値との比較を1行で書ける
3. 配列の要素を簡単にチェックできる

### 注意点
- 大文字小文字は区別される（"Apple" と "apple" は別物として扱われる）
- 完全一致でチェックされる（部分一致は検出されない） 

## 配列メソッド

### メソッドとは？
- オブジェクトや配列が持っている特別な機能（関数）
- ドット（.）をつけて呼び出す
- 例：`配列.メソッド名()`

### 主な配列メソッド一覧

| メソッド名 | 説明 | 使用例 | 結果 |
|------------|------|--------|------|
| `includes()` | 配列に特定の要素が含まれているかを確認 | `["りんご", "みかん"].includes("りんご")` | `true` |
| `forEach()` | 配列の各要素に対して処理を実行 | `[1, 2, 3].forEach(num => console.log(num))` | 1, 2, 3を順に表示 |
| `push()` | 配列の末尾に要素を追加 | `fruits.push("バナナ")` | 配列の最後にバナナを追加 |
| `pop()` | 配列の末尾の要素を削除して返す | `fruits.pop()` | 最後の要素を削除して返す |
| `shift()` | 配列の先頭の要素を削除して返す | `fruits.shift()` | 最初の要素を削除して返す |
| `unshift()` | 配列の先頭に要素を追加 | `fruits.unshift("りんご")` | 配列の先頭にりんごを追加 |
| `slice()` | 配列の一部を切り出して新しい配列を作成 | `fruits.slice(1, 3)` | インデックス1から2までの要素を取得 |
| `join()` | 配列の要素を結合して文字列にする | `["a", "b", "c"].join("-")` | "a-b-c" |
| `map()` | 各要素に処理を適用して新しい配列を作成 | `[1, 2, 3].map(n => n * 2)` | `[2, 4, 6]` |
| `filter()` | 条件に合う要素だけを抽出して新しい配列を作成 | `[1, 2, 3].filter(n => n > 1)` | `[2, 3]` |

### メソッドの使い分けポイント
1. **要素の追加・削除**
   - 末尾の操作：`push()`/`pop()`
   - 先頭の操作：`unshift()`/`shift()`

2. **要素の検索・確認**
   - 存在確認：`includes()`
   - 条件検索：`filter()`

3. **要素の変換・加工**
   - 全要素の処理：`forEach()`
   - 新しい配列作成：`map()`
   - 文字列化：`join()`

4. **部分取り出し**
   - 範囲指定：`slice()`

### 使用例
```javascript
// 果物の配列
const fruits = ["りんご", "バナナ", "オレンジ"];

// forEach()で全要素を表示
fruits.forEach(fruit => console.log(fruit));

// includes()で存在確認
if (fruits.includes("りんご")) {
    console.log("りんごがあります！");
}

// map()で新しい配列作成
const fruitMessages = fruits.map(fruit => `${fruit}があります`);
``` 

## HTMLとCSS

### trタグとdivタグの適切な使い分け方 📝 2025/04/21

HTMLでテーブル（表）を作成する際と単純なレイアウト目的での要素の使い分け方について整理しました。

#### trタグの用途と特徴
- `<tr>` (table row)はテーブル（`<table>`）内で行を表現するための専用タグ
- 必ず`<table>`の中で使用する必要がある
- `<tr>`の中には`<td>`（テーブルデータ）や`<th>`（テーブルヘッダー）要素を配置する
- 表形式のデータを表現する時に適している
- テーブルのセマンティクス（意味構造）を正しく表現できる

```html
<table>
  <tr>
    <th>ヘッダー1</th>
    <th>ヘッダー2</th>
  </tr>
  <tr>
    <td>データ1</td>
    <td>データ2</td>
  </tr>
</table>
```

#### divタグの用途と特徴
- `<div>`はブロックレベル要素を作る汎用的なコンテナ
- レイアウトの区切りや、スタイルを適用するためのグループ化に使用
- 意味的な構造を持たないため、純粋にレイアウト目的に適している
- CSSと組み合わせて柔軟なデザインが可能

```html
<div class="container">
  <div class="row">
    <div class="cell">データ1</div>
    <div class="cell">データ2</div>
  </div>
</div>
```

#### 使い分けのポイント
1. **データの性質を考慮**: 表形式のデータを表示する場合は`<table>`を使用
2. **アクセシビリティ**: スクリーンリーダーなどの支援技術を使用するユーザーのために、データの構造を正しく伝えるためにも適切な要素を選択する
3. **レスポンシブデザイン**: 単純なレイアウト目的なら`<div>`の方が柔軟に対応できる

#### 注意点
- 昔はテーブルレイアウト（`<table>`を使ったページのレイアウト）が一般的だったが、現在はCSSを使った方法が推奨されている
- SEOの観点からも、適切な要素を使うことが重要

### マークダウンでの画像表示と調整方法
### マークダウンでの画像表示と調整方法 📝 2025/04/21

マークダウンでは通常、以下の形式で画像を挿入します：

```markdown
![代替テキスト](画像のURL "オプションのタイトル")
```

しかし、サイズ調整やセンタリングなどの細かい制御が必要な場合は、HTMLタグを使用することができます。

#### 画像サイズの調整
```html
<img src="画像のパス" width="300" height="200" alt="代替テキスト">
```

#### 画像の中央揃え
```html
<div align="center">
  <img src="画像のパス" alt="代替テキスト">
</div>
```

#### 画像にリンクを設定
```markdown
[![代替テキスト](画像のパス)](リンク先URL)
```

#### スタイルを適用した画像
```html
<img src="画像のパス" alt="代替テキスト" style="border: 1px solid #ddd; border-radius: 8px; padding: 5px;">
```

#### 画像のフロート（テキスト回り込み）
```html
<img src="画像のパス" alt="代替テキスト" style="float: right; margin: 0 0 10px 10px;">
テキストがここに入ります。画像は右側に配置され、テキストが画像の周りに回り込みます。
<div style="clear: both;"></div><!-- フロートのクリア -->
```

#### 注意点
- GitHubやNotion等のプラットフォームでは、セキュリティ上の理由からHTMLタグの一部が制限されていることがある
- マークダウンの実装によって、対応しているHTMLタグやCSSプロパティが異なる場合がある
- 複雑なレイアウトが必要な場合は、純粋なHTMLドキュメントを作成した方が柔軟性が高い 

## ビューポートメタタグ
### ビューポートメタタグの役割と設定方法
```html
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

この設定は2つの重要な部分から成ります：

1. **width=device-width**
   - ページの幅をデバイスの画面幅に合わせる
   - 様々な画面サイズのデバイスで適切に表示される

2. **initial-scale=1.0**
   - 初期表示時のズームレベルを100%（等倍）に設定
   - ページが拡大・縮小されずにそのままの比率で表示される

**重要性**：
- モバイルデバイスでの適切な表示を保証
- レスポンシブデザインの基盤となる設定
- ユーザーが拡大操作なしでコンテンツを閲覧できる
- メディアクエリと組み合わせて異なる画面サイズに対応

## 箇条書きのインデント調整
### 箇条書きの2行目以降を揃える方法（2025/04/21）
- 問題点
  - 箇条書きの2行目以降がマーク（・）よりも左に揃ってしまう
  - 長文の場合、テキストが左端から始まるため読みにくくなる
  
- 解決方法：text-indentプロパティの活用
  ```css
  li {
    padding-left: 1.5em;  /* マークより右側にテキスト全体を配置 */
    text-indent: -1.5em;  /* 最初の行だけ左にずらす（マークを表示） */
  }
  ```
  
- 仕組みの解説
  1. `padding-left: 1.5em;` でリスト全体を右側にずらす
  2. `text-indent: -1.5em;` で最初の行だけ左に戻す（負の値）
  3. 結果として、マークは元の位置に、2行目以降はマークの右に揃う
  
- 応用例（カスタム箇条書き）
  ```css
  .custom-list {
    list-style: none;  /* 標準の箇条書きマークを非表示 */
  }
  
  .custom-list li {
    padding-left: 1.4em;
    text-indent: -1.4em;
  }
  
  .custom-list li:before {
    content: "✓";  /* カスタムマーク */
    margin-right: 0.4em;
  }
  ```
  
- 注意点
  - padding-leftとtext-indentの値は一致させるのが基本
  - emやremなどの相対単位を使うと、フォントサイズが変わっても調整される
  - ネストされたリストでは、階層ごとに異なる値を設定すると良い

## CSSプロパティの継承に関する注意点 📝
### 継承されるプロパティと継承されないプロパティ（2025/04/21）
- 継承されるプロパティ（親要素から子要素に自動的に引き継がれる）
  - `color` - テキストの色
  - `font-family` - フォントの種類
  - `font-size` - フォントサイズ
  - `font-weight` - フォントの太さ
  - `line-height` - 行の高さ
  - `text-align` - テキストの配置
  - `visibility` - 表示/非表示（スペースは維持）
  
- 継承されないプロパティ（子要素に自動的に引き継がれない）
  - `margin`, `padding` - 余白関連
  - `border` - 境界線
  - `background` - 背景
  - `width`, `height` - サイズ
  - `position` - 配置方法
  - `display` - 表示形式
  - `z-index` - 重ね順
  
- 継承を制御するための値
  - `inherit` - 親要素の値を強制的に継承させる
  - `initial` - ブラウザの初期値に戻す
  - `unset` - 継承するプロパティは継承し、しないプロパティは初期値に戻す
  
- 実用例
  ```css
  /* すべてのボタンに親要素のフォントカラーを継承させる */
  button {
    color: inherit;
  }
  
  /* ボックスの背景色を強制的にリセットする */
  .reset-box {
    background-color: initial;
  }
  ```
  
- 注意点
  - 継承は直接の親だけでなく、先祖要素からも引き継がれる
  - CSSの詳細度（セレクタの強さ）によって継承よりも強いルールが適用される場合がある
  - `!important`を使うと継承よりも優先される

## transformプロパティのアニメーション 📝
### transform: rotate()を使った要素の回転（2025/04/21）
- 基本構文
  ```css
  .element {
    transform: rotate(90deg); /* 時計回りに90度回転 */
    transition: transform 0.5s; /* 0.5秒かけて回転するアニメーション */
  }
  ```
- 主な回転値
  - `rotate(45deg)` - 時計回りに45度回転
  - `rotate(-90deg)` - 反時計回りに90度回転
  - `rotate(0.5turn)` - 180度回転（turnは1回転を表す単位）
- 回転の中心点の変更
  ```css
  .element {
    transform-origin: top left; /* 左上を中心に回転 */
    transform: rotate(45deg);
  }
  ```
- 実用例：ボタン内の矢印アイコンを回転
  ```css
  .accordion-header.active .arrow {
    transform: rotate(180deg); /* アコーディオンが開いたときに矢印を回転 */
  }
  ```
- 注意点
  - 回転は要素の表示位置を変えるだけで、ドキュメントのレイアウトには影響しない
  - 3D回転をするには `rotateX()`, `rotateY()`, `rotateZ()` を使用する

## 【CSS関連】

### CSS基本プロパティと使い方

#### ホバー効果とカーソルプロパティ

**ホバー（:hover）疑似クラス**

ホバーとは、マウスカーソルを要素の上に置いた状態のことです。CSSでは`:hover`疑似クラスを使用して、この状態の時のスタイルを指定できます。

**基本的な使い方:**
```css
.button:hover {
  background-color: blue;  /* ホバー時は背景色が青に変わる */
}
```

#### CSS擬似要素（::before, ::after）

擬似要素とは「HTMLには書いていないけど、CSSだけで追加できる架空の要素」のことです。HTMLを変更せずにCSSだけで内容を追加できる強力な機能です。

**主な擬似要素:**
- **::before** - 要素の中身の前に何かを追加
- **::after** - 要素の中身の後に何かを追加

**基本的な使い方:**
```css
.example::before {
  content: "★"; /* 必須プロパティ。挿入する内容を指定 */
  color: red;    /* 通常の要素と同様にスタイリングできる */
}

.example::after {
  content: "☆";
  margin-left: 5px;
}
```

**実用例（アコーディオンメニューの+/-アイコン）:**
```css
.accordion-header::after {
  content: '+';   /* + 記号を挿入 */
  float: right;   /* 右側に配置 */
}

/* アクティブ状態では - 記号に変更 */
.accordion-header.active::after {
  content: '-';
}
```

**擬似要素を使うメリット:**
.menu-toggle span {
  display: block;
  width: 2rem;      /* 横幅 */
  height: 0.2rem;   /* 高さ（薄さ） */
  margin-bottom: 0.4rem; /* 線と線の間隔 */
  background-color: #3F3F3F; /* 線の色 */
}
```

**わかりやすく説明すると：**
1. まず、何も書いていない空っぽの紙（spanタグ）を3枚用意します
2. その紙をそれぞれ細長い形（width: 2rem, height: 0.2rem）に切ります
3. 切った紙全体に灰色の絵の具（background-color）を塗ります
4. それを上から順に少し間隔（margin-bottom）をあけて重ねます

これで「≡」のようなハンバーガーメニューの形になります！
「背景色」と呼ばれるのは、この「紙」自体に色を塗っているからです。文字ではなく、要素そのものに色をつけています。

### ハンバーガーメニューとnavタグの関係

ハンバーガーメニューアイコンをクリックすると表示されるのが「navタグ」の中身です：

```html
<!-- ハンバーガーアイコン -->
<button class="menu-toggle">
  <span></span>
  <span></span>
  <span></span>
</button>

<!-- 実際のメニュー内容（クリックで表示される） -->
<nav class="nav-links">
  <ul>
    <li><a href="#home">ホーム</a></li>
    <li><a href="#about">about</a></li>
    <li><a href="#contact">お問い合わせ</a></li>
  </ul>
</nav>
```

**わかりやすく説明すると：**
1. ハンバーガーアイコン（button.menu-toggle）はただの「スイッチ」です
2. 実際のメニュー内容は「navタグ」の中に入っています
3. 最初はnavタグを隠しておきます（`display: none;`）
4. ハンバーガーアイコンをクリックすると、JavaScriptが動いて：
   - navタグに`active`というクラスをつけます
   - `nav-links.active { display: block; }`でメニューが表示されます

つまり、ハンバーガーアイコンはただの見た目で、実際のメニュー内容はnavタグで作り、JavaScriptで表示/非表示を切り替えているのです！


## ワークスペースとGit管理について

### ワークスペースに名前をつける
- ワークスペース自体に特定の名前をつけることはできませんが、フォルダ名を変更することで、ワークスペースの名前を変えることができます。
- 例えば、`study`フォルダの名前を変更すれば、その名前がワークスペース名として扱われます。

### Git管理とリポジトリ
- ワークスペース内に複数のリポジトリを持つことができます。それぞれのリポジトリは独立して管理されます。
- 各リポジトリは、そのフォルダ内でGitの初期化を行い、`.git`フォルダが存在することで管理されます。
- 同じワークスペース内でも、リポジトリごとに異なるバージョン管理が適用されます。

これにより、プロジェクトごとに独立したバージョン管理を行うことができ、効率的に作業を進めることができます。 


# .gitignoreファイルの重要性と正しい配置

## .gitignoreとは
- Gitが追跡しないファイル/ディレクトリを指定するための設定ファイル
- 一時ファイル、ビルド成果物、依存関係ファイルなど不要なファイルをGit管理から除外する

## 正しい配置場所
- **ルートディレクトリ**（プロジェクトのトップフォルダ）に配置するのが基本
- サブディレクトリにも置けるが、その場合はそのディレクトリ以下にのみ効果がある

## ルートディレクトリに置く理由
1. **エラーが少ない**: 標準的な位置なので予測通りに動作する
2. **プロジェクト全体に適用**: すべてのサブディレクトリに効果が及ぶ
3. **共同作業の円滑化**: 他の開発者と共同作業する際の混乱を防ぐ
4. **予測可能な動作**: `node_modules`や`.DS_Store`などを確実に除外できる


## よくある問題と対処法
- **問題**: .gitignoreを移動/削除すると、今まで無視されていたファイルが「未追跡(untracked)」として表示される
- **対処法**: .gitignoreをルートディレクトリに戻し、適切な無視設定を記述する
- **注意点**: 一度Gitに追加されたファイルは.gitignoreに追加しても無視されない（キャッシュの削除が必要）

## 重要なポイント
- 設定ファイルの位置がGitの動作に大きく影響する
- ファイル構成を変更する際はGitへの影響も考慮する
- 大規模なプロジェクトほど.gitignoreの正確な管理が重要

# 通信の基本：IPアドレス・MACアドレス・ポート番号まとめ

## 📍 用語の役割まとめ

| 項目 | 例 | 役割 | 固定？ | 付与元 |
|------|----|------|--------|--------|
| **MACアドレス** | 26:08:49:A9:C6:65 | 機器そのものに付いたID | 基本固定 | 工場で決定（機器に内蔵） |
| **IPアドレス** | 192.168.1.5 | ネット上の住所 | 変わることが多い | ルーター（DHCP）などが割り当て |
| **ポート番号** | :80, :443 など | アプリ・サービスの入り口 | 毎回違う場合あり | ソフトウェア側で動的割当 or 決め打ち |

---

## 📡 IPアドレスとは？

- インターネット上の「住所」。
- データの送受信で「誰に送るか」「誰から届いたか」を判断するために使う。
- 家や図書館など、接続するネットワークが変わるとIPも変わる（動的IPが主流）。

### 🔸 種類
- **グローバルIP**：インターネット全体でユニーク。ルーターなどが持つ。
- **プライベートIP**：家庭や職場内のネットワーク用（192.168.x.xなど）。

---

## 🆔 MACアドレスとは？

- 通信機器（スマホやPC）に最初から割り当てられている**世界で一つのID**。
- 通信時、ルーターなどの機器が相手を識別するために使う。
- iPhoneでは「Wi-Fiアドレス」と表示される。

### 🔸 iPhoneでの見え方
- 「設定」→「Wi-Fi」→「接続中のネットワーク」をタップ
- `Wi-Fiアドレス` = **MACアドレス**
- `プライベート Wi-Fi アドレス` = **仮のMACアドレス（追跡防止用）**

---

## 🚪 ポート番号とは？

- IPアドレスだけでは「どのアプリに送るか」がわからない。
- ポート番号は機器内の**アプリやサービスの"入り口番号"**。
- 複数のアプリが同時に通信できるように、番号で整理。

### 🔸 代表的なポート番号
| サービス | ポート番号 |
|----------|------------|
| Web (HTTP) | 80 |
| Web (HTTPS) | 443 |
| メール送信 (SMTP) | 25 |
| メール受信 (POP3) | 110 |

---

## 🔐 プライベートWi-Fiアドレスとは？

- iPhoneなどが**毎回違うMACアドレスを使ってWi-Fiに接続する仕組み**。
- 「トラッキング（追跡）」防止が目的。
- Wi-Fiネットワークごとに仮のMACアドレスを使うことで、位置や行動を把握されにくくしている。

> `設定 → Wi-Fi → [ネットワーク] → 「プライベートWi-Fiアドレス」ON` が該当設定。

---

## 🧾 補足：Wi-Fi接続履歴と追跡について

- 通信相手（ルーターや企業側）は、あなたのMACアドレスやIPアドレスをログに残せる。
- 特に公共Wi-Fiや職場ネットワークでは、**「いつ」「どの端末」がつないだか**が記録されている可能性あり。
- 「プライベートWi-Fiアドレス」を使えばある程度の追跡回避は可能。

---

## 🧠 イメージで覚える！

# RSSまとめノート

## ✅ RSSとは？

- **RSS（Really Simple Syndication）**とは、Webサイトの**更新情報を自動配信するための仕組み**
- たとえばブログやニュースサイトなどで、新しい記事やお知らせが投稿されたときにその情報を**RSSリーダー（例：Feedly）でまとめて受け取れる**
- 更新情報は **XML形式**の「RSSフィード」として公開されている
- 情報収集の効率化、自分用の"情報ダッシュボード"を作るのに便利！

---

## 🛠 RSSの設定方法（WebサイトをRSS対応にする方法）

### ▶ 静的サイトでの基本手順

1. **RSSフィード（rss.xml）ファイルを作る**
    - サイトのタイトル・URL・説明・記事のタイトルや日付などをXML形式で記述する
    - 以下は基本的な構造：

    ```xml
    <?xml version="1.0" encoding="UTF-8" ?>
    <rss version="2.0">
      <channel>
        <title>サイトの名前</title>
        <link>https://example.com</link>
        <description>サイトの説明</description>
        <language>ja</language>
        <lastBuildDate>Tue, 28 May 2025 17:00:00 +0900</lastBuildDate>

        <item>
          <title>記事タイトル</title>
          <link>https://example.com/post1</link>
          <description>記事の概要</description>
          <pubDate>Tue, 28 May 2025 15:00:00 +0900</pubDate>
        </item>
      </channel>
    </rss>
    ```

2. **その `rss.xml` ファイルをサイトにアップロード**
    - `/rss.xml` などの名前で配置（静的サイトなら `public/` ディレクトリなど）

3. **HTMLの`<head>`タグにリンクを追加**

    ```html
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml" />
    ```

    → これでブラウザやRSSリーダーが自動で検出できるようになる

---

## 🔍 RSSの取得方法（使う側の視点）

### ▶ RSSリーダーを使って情報を取得

例：Feedly

1. [https://feedly.com](https://feedly.com) にアクセスしてアカウント作成（無料）
2. 検索バーに **RSSフィードのURL** を入力（例：`https://qiita.com/tags/javascript/feed`）
3. 検索結果から「+Follow」ボタンを押して登録
4. 登録後はFeedlyのホームで更新情報を一覧表示！

#### 📝 RSSフィードURLの例

| サイト           | RSSフィードURL例                                  |
|------------------|--------------------------------------------------|
| Qiita（JavaScriptタグ） | `https://qiita.com/tags/javascript/feed`       |
| NHKニュース       | `https://www3.nhk.or.jp/rss/news/cat0.xml`       |
| CodePenブログ     | `https://blog.codepen.io/feed/`                 |

---

## 🔁 補足：RSSに非対応のサイトは？

- RSSがないページでも、**Web監視アプリ**（例：Visualping, Distill.io）を使えば、変更を自動通知できる
- RSSとWeb監視アプリは補完的に使える

---

## ✅ まとめ

- RSSは、**サイトの新着情報を効率よくまとめて取得できる仕組み**
- サイト運営側は `rss.xml` を作って `<head>` にリンクするだけでOK
- 利用者側はFeedlyなどで好きなRSSを登録するだけで、**自分だけの情報ダッシュボード**ができる



# GitHubプッシュでVercel自動デプロイ【仕組みまとめ】（2025/6/1）

---

## 仕組み

1. GitHubリポジトリにコードを**push**する
2. VercelがGitHubの変更を**自動検知**する
3. Vercelが最新コードを使って**自動デプロイ**する
4. **URLは変わらず**そのまま更新される

---

## 図でイメージ

```
GitHubリポジトリ
    ↓（push）
Vercel
    ↓（自動デプロイ）
WebサイトURL（常に最新）
```

---

## ポイント

- **pushだけ**でデプロイ完了
- **URLは変わらない**からリンク変更不要
- **手動デプロイ作業なし**
- **mainブランチ**など指定したブランチが対象
- **初回だけ**GitHubとVercelの連携設定が必要

---

## 注意点

- push先が設定した**ブランチ**（通常は`main`）か確認
- エラーがあればVercelのデプロイログで確認

---

## メリット

- 作業の手間が減る
- デプロイ忘れがなくなる
- スピーディに公開できる

# 【CSS】クラスを組み合わせて使う設計：ユーティリティクラス（共通クラス）
（2025/6/3）
---

## ✅ これは何？

- **クラス名は自由**に決めていい
- **スペース区切りで複数クラスを同時指定**できる
- これを使って、**共通デザインだけを切り出したクラス**を作る方法
- **この方法は正式には：**  
  → **「ユーティリティクラス」**とか  
  → **「共通クラス」**と呼ばれるやり方！

---

## ✅ 例

```html
<div class="card box"> ... </div>
<div class="instructions box"> ... </div>
```

| クラス         | 役割・意味                             |
|:---------------|:--------------------------------------|
| `.card`        | ミッションカード専用のデザイン設定       |
| `.instructions`| 説明セクション専用のデザイン設定         |
| `.box`         | **共通のデザインをまとめたクラス**        |

---

## ✅ どんな効果？

- 1つのクラスに**共通スタイル**（背景・角丸・ネオンなど）
- もう1つのクラスに**個別スタイル**（カード枠線、左線など）
- **スタイルを継承しつつ個別カスタム**できる！
- **クラス名は完全に自由！**

---

## ✅ CSSサンプル

```css
.box {
  width: 90%;
  max-width: 600px;
  padding: 2em;
  background: #1e1e1e;
  border-radius: 12px;
  box-shadow: 0 4px 8px rgba(0, 255, 153, 0.2); /* ボワボワネオン */
}

/* カードだけのデザイン */
.card {
  border: 2px solid #00FF88; /* 緑の枠線 */
}

/* 説明だけのデザイン */
.instructions {
  border-left: 5px solid #00FF88; /* 左線強調など */
}
```

---

## ✅ 大事なポイント

- クラス名は任意！好きに付けてOK！
- スペース区切りで**複数のクラスを併用**する
- 共通の見た目だけを切り出したクラスを作る  
→ これを**ユーティリティクラス**（共通クラス）と呼ぶ！

---

## ✅ さらに深掘り

- BootstrapなどのCSSフレームワークもこの考え方でできている
- ユーティリティクラスは**管理が楽・使い回しができる**

---
# パスワード入力フォームのコード構造

## HTML構造

#### 🔧 使用タグと属性

| タグ        | 役割                                      |
|-------------|-------------------------------------------|
| `<form>`    | 入力フォーム全体をまとめる箱              |
| `<label>`   | 入力欄につける説明ラベル                  |
| `<input>`   | ユーザーが実際に入力する欄（text, passwordなど） |
| `<button>`  | 送信や処理をトリガーするボタン            |

---

| 属性名   | 使う場所         | 意味                          |
|----------|------------------|-------------------------------|
| `for`    | `<label>`に書く  | どの`<input>`とペアかを指定（`id`を参照） |
| `id`     | `<input>`に書く  | 自分の識別名。JavaScriptやCSSからも使える |

#### 🔗 JavaScriptとつなげるために必要なこと

- `<input>` に **`id` をつける**（JavaScriptから特定するための"名札"）
- JavaScriptで `getElementById("id名").value` を使って入力値を取得する

#### ⭐️理解のポイント

- `input` タグは「入力箱」  
- `id` をつけておけば JavaScript がその箱を開けられる  
- `label` の `for` 属性で`id`との関係が視覚的・構造的にもつながる

#### ✅ 実例コード

```html
<form id="loginForm">
  <label for="username">ユーザー名：</label>
  <input type="text" id="username" name="username" />
  
  <label for="password">パスワード：</label>
  <input type="password" id="password" name="password" />

  <button type="submit">ログイン</button>
</form>
```

## JavaScript構造
2025/5/30
#### 🔧 使用構文と機能

| 構文・プロパティ | 役割 |
|------------------|------|
| `===` | 厳密な比較（値と型の両方が一致しているか判定） |
| `&&` | 論理積（AND）。両方の条件が true のときだけ true になる |
| `.value` | input に入力された値をJavaScriptで取り出すプロパティ |
| `.textContent` | 要素内のテキストを書き換えるプロパティ |
| `.style.color` | 要素の文字色を変更するCSSプロパティのJS版 |

---

| メソッド・イベント | 使う場所 | 意味 |
|-------------------|----------|------|
| `getElementById()` | JavaScript | 指定したidの要素を取得する |
| `addEventListener()` | JavaScript | イベント（クリック、送信など）を監視する |
| `event.preventDefault()` | イベント処理内 | 本来のフォーム送信（リロード）をキャンセル |

#### 🎯 この練習でやったこと

- `<form>` からの入力値を JavaScript で受け取る
- `===`（厳密な比較）と `&&`（論理積）を使ってログイン認証処理を作る
- `event.preventDefault()` を使ってページのリロードを止め、JSで判定処理が見えるようにした

#### ⭐️理解のポイント

- JavaScriptでは、**値の取得→条件判定→結果表示** までを自分で組み立てられる！
- `===` と `&&` は、ログイン認証などの「正しさのチェック」に欠かせない基本構文
- `preventDefault()` を書くことで、ページが勝手にリロードされるのを防げる

#### ✅ 処理の流れ

1. **入力値取得**: `getElementById().value` で入力内容を取得
2. **条件判定**: `===` と `&&` で正しいユーザー名・パスワードかチェック
3. **結果表示**: `textContent` と `style.color` でメッセージと色を変更

## 💻 使用コード（HTML＋JavaScript）

```html
<form id="loginForm">
  <label for="username">ユーザー名：</label>
  <input type="text" id="username" name="username" required />

  <label for="password">パスワード：</label>
  <input type="password" id="password" name="password" required />

  <button type="submit">ログイン</button>
</form>

<p id="message"></p>

<script>
  const form = document.getElementById('loginForm');
  const message = document.getElementById('message');

  form.addEventListener('submit', function(event) {
    event.preventDefault(); // フォームの送信を止める、ページリロードされて処理が見えなくなるのを防ぐ

    const username = document.getElementById('username').value;
    const password = document.getElementById('password').value;

    // 入力確認（開発用）
    console.log('ユーザー名:', username);
    console.log('パスワード:', password);

    // ログイン判定処理
    // username が "admin" AND password が "1234" と一致したら成功
    if (username === 'admin' && password === '1234') {
      message.textContent = '♡';
      message.style.color = 'green';
    } else {
      message.textContent = 'ユーザー名またはパスワードが違います';
      message.style.color = 'red';
    }
  });
</script>

# 🖐️テーブルタグ `<table>` まとめ

---

## テーブルって？

テーブルは**表**を作るためのタグ。  
算数の九九の表とか、給食の献立表みたいな感じ！

---
## 使うタグ

| タグ       | 何を作る？           | 使い方イメージ                   |
|:-----------|:--------------------|:---------------------------------|
| `<table>`  | テーブルの外側         | 表ぜんたいを囲うよ                |
| `<thead>`  | テーブルのあたま部分   | タイトル行を入れるよ             |
| `<tbody>`  | テーブルの中身部分     | 本文の行たちを入れるよ           |
| `<tr>`     | 1行（横のライン）を作る | 1行ずつ包むよ（ヘッダーも本文も） |
| `<th>`     | タイトル用のセル       | ふつう上の行に使う（太字になる）   |
| `<td>`     | 本文用のセル           | ふつうのマス目に使うよ           |

---

## イメージ

```html
<table>
  <thead>
    <tr>
      <th>教科</th>   <!-- タイトル -->
      <th>点数</th>   <!-- タイトル -->
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>国語</td>   <!-- データ -->
      <td>90</td>     <!-- データ -->
    </tr>
    <tr>
      <td>算数</td>
      <td>80</td>
    </tr>
  </tbody>
</table>
```

---

## ポイント

- `<th>`：**タイトル**のセル。文字が**太字**で**中央寄せ**になるのがポイント！
- `<td>`：**データ**のセル。ふつうの文字。
- `<tr>`：**1行ごと**に包むよ。
- `<thead>`と`<tbody>`は、**ヘッダー**と**本文**を分けてあげると  
  画面リーダーやSEO的にGOOD！

---

## まとめ

- **タイトルのとこ**に使うのが `<th>`！
- **データのとこ**に使うのが `<td>`！

---


<br>
<br>
# 🖐️ `type="submit"` とは

---

## ① ボタンを押すと、フォームに**お手紙**を送るスタート！

フォームってこういう形だよね？

```html
<form>
  <input>  <!-- 名前を書くところ -->
  <button type="submit">お手紙を送るボタン</button>
</form>
```

---

## ② ボタンを押すと、こんなことが起きるよ！

1. **ちゃんと書けてるかチェック**
   - 名前やパスワードが空っぽじゃないかな？
   - へんな文字じゃないかな？
   - コンピューターが**自動でチェック**してくれるよ！

2. **チェックOKならお手紙を送る**
   - 名前やパスワードを、サーバーに**お手紙**として送る！
   - サーバーは、インターネットの向こうにいるコンピューターのことだよ。

3. **新しいページにジャンプ**
   - お手紙を送ったら、**新しいページ（URL）に飛んでね！**ってなる！

---

## ③ でも！ページを飛びたくないときは？

プログラムでこう書くよ！

```javascript
form.addEventListener('submit', (event) => {
  event.preventDefault(); // ← 飛ばないように止める呪文！
  console.log('ボタンは押されたけど、ページはそのまま！');
});
```

→ これで、**ページをそのままにして**、好きなこと（ログインチェックとか）ができるよ！

---

## 🎯 いちばん大事なこと！

| ボタンを押すと...             | なにが起きる？                      |
|:------------------------------|:------------------------------------|
| ①                             | 入力したものをチェックするよ！       |
| ②                             | OKならサーバーにお手紙を送るよ！     |
| ③                             | 新しいページにジャンプするよ！       |
| 🚫                            | でもプログラムで止めることもできるよ！ |

---

## 💡 たとえば

- **メールアドレス**が空っぽだと、「入れてね！」って言われる。
- **ボタンを押したら**ログインできる。
- **プログラムで止めれば**、ページがそのままでメッセージを出せる。

---

📝 小学生にもわかるように言うと…

> `submit`ボタンは、フォームへの**お手紙を送るスタートボタン**！  
> でも、先生（プログラム）が「ちょっと待って！」って止めることもできる！
# アイコン切り替え機能

**学習日：** 2025/06/08  
**カテゴリ：** JavaScript

## 📖 概要
- 目アイコンでパスワード表示／非表示を切り替える仕組みを学習。

## 🔍 詳細内容

### パスワード可視化切替アイコン（Eye Toggle）
- **役割・定義：**
  - `<input type="password">` の横にアイコンを置き、クリックで `text` に変更し可視化。
- **使用場面：**
  - パスワード入力フォームでミスタイプ防止や確認のために使う。
- **コード例：**
  ```html
  <div class="input-wrap">
    <input type="password" id="password">
    <i class="fas fa-eye toggle-eye" id="togglePassword"></i>
  </div>
  ```
  ```js
  document.addEventListener("DOMContentLoaded", () => {
    const toggle = document.getElementById("togglePassword");
    const pwd = document.getElementById("password");

    toggle.addEventListener("click", () => {
      // type属性を切り替え
      pwd.type = pwd.type === "password" ? "text" : "password";
      // アイコンも切り替え
      toggle.classList.toggle("fa-eye");
      toggle.classList.toggle("fa-eye-slash");
    });
  });
  ```
- **ポイント：**
  - `input.type` を直接変更すると可視化が切り替わる
  - `classList.toggle()` で Font Awesome の `fa-eye` ⇄ `fa-eye-slash` を切替

## 💡 学んだこと・気づき
- Font Awesome は手軽だが
  - Retinaディスプレイだとシャープさに欠けることがある
  - スクリーンリーダー向けに `<span class="sr-only">目アイコン</span>` が必要
- SVGアイコンだと
  - 鮮明／複雑な表現可能／`aria-label`などでアクセシブルに使える
- JavaScriptでは
  - `input.type = ...` の直接操作がすっきり書けておすすめ
- 実際に100y_mementoプロジェクトで実装した際の感情の流れ設計メモ：[感情の流れ設計](../../100y_memento/docs/emotional-flow.md)
- プロジェクト全体の技術的な詳細：[100y_mementoプロジェクト概要](../../100y_memento/README.md)
